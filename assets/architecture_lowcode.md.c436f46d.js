import{_ as a,o as e,c as t,Q as o}from"./chunks/framework.058c99df.js";const u=JSON.parse('{"title":"低代码","description":"","frontmatter":{},"headers":[],"relativePath":"architecture/lowcode.md"}'),r={name:"architecture/lowcode.md"},i=o('<h1 id="低代码" tabindex="-1">低代码 <a class="header-anchor" href="#低代码" aria-label="Permalink to &quot;低代码&quot;">​</a></h1><h2 id="json-schema" tabindex="-1">JSON Schema <a class="header-anchor" href="#json-schema" aria-label="Permalink to &quot;JSON Schema&quot;">​</a></h2><p>JSON Schema 本身就是一种数据结构，可以清晰的描述 JSON 数据的结构。是一种描述 JSON 数据的 JSON 数据。</p><h2 id="低代码平台需要具备哪些能力" tabindex="-1">低代码平台需要具备哪些能力 <a class="header-anchor" href="#低代码平台需要具备哪些能力" aria-label="Permalink to &quot;低代码平台需要具备哪些能力&quot;">​</a></h2><ul><li>面向业务的软件设计模式，低代码主要是给运营用的，通过模块or组件的使用，给运营人员提供物料，搭建他们自己想要的营销活动页面。</li><li>能够提供可复用业务组件的知识库，组件之间可以相互联合，组成新的业务组件，而不是单一独立的基础组件，可复用性、可拓展性非常高。</li><li>能够方便实现与第三方系统整合的流程整合能力与数据整合能力等，能够以SDK，或者npm包的形式嵌入到其他应用，或者其他应用嵌入进来，支持数据之间的整合。</li><li>能够支持多种部署模式，不受平台本身的限制</li><li>支持高度可配置化，以满足不同环境、不同规模、不同业务场景的特定要求</li></ul><h2 id="amis" tabindex="-1">Amis <a class="header-anchor" href="#amis" aria-label="Permalink to &quot;Amis&quot;">​</a></h2><p>Schema，即组件的 JSON 配置</p><p>amis 的渲染过程是将 json 转成对应的 React 组件。先通过 json 的 type 找到对应的 Component 然后，然后把其他属性作为 props 传递过去完成渲染。</p><p>一个节点要被什么组件渲染，还需要携带上下文（context）信息，amis 中是用节点的路径（path）来作为上下文信息</p><p>根据 path 的信息就能很容易注册组件跟节点对应了</p><p>渲染过程就是根据节点 path 信息，跟组件池中的组件 test (检测) 信息做匹配，如果命中，则把当前节点转给对应组件渲染，节点中其他属性将作为目标组件的 props （数据域、数据链、模板、数据映射、表达式、联动）</p><h2 id="vue-form-making" tabindex="-1">vue-form-making <a class="header-anchor" href="#vue-form-making" aria-label="Permalink to &quot;vue-form-making&quot;">​</a></h2><p>提供 表单设计器（MakingForm）和表单生成器（GenerateForm）两个组件，通过表单设计器快速设计出表单页面，生成可配置 json 和可直接运行的代码，使用表单生成器快速渲染出表单页面 里面所有的组件渲染都是 v-if 判断 type 来写的，我们的技术预演就是基于它使用 vue3+tsx 来完成的重构，使用 component：is 来完成组件渲染</p>',13),n=[i];function s(c,l,h,m,p,d){return e(),t("div",null,n)}const f=a(r,[["render",s]]);export{u as __pageData,f as default};
