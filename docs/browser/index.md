## 输入URL

- 首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。

- 浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。

1. 首先做 DNS 查询，如果这一步做了智能 DNS 解析的话，会提供访问速度最快的 IP 地址回来

2. 接下来是 TCP 握手，应用层会下发数据给传输层，这里 TCP 协议会指明两端的端口号，然后下发给网络层。网络层中的 IP 协议会确定 IP 地址，并且指示了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了

3. TCP 握手结束后会进行 TLS 握手，然后就开始正式的传输数据

4. 数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上，这时假设服务端会响应一个 HTML 文件

5. 首先浏览器会判断状态码是什么，如果是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错

6. 浏览器开始解析文件，如果是 gzip 格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件

浏览器渲染过程:

7. 文件解码成功后会正式开始渲染流程，先会根据 HTML 构建 DOM 树，有 CSS 的话会去构建 CSSOM 树。如果遇到 script 标签的话，会判断是否存在 async 或者 defer ，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 HTML 解析完成后顺序执行，如果以上都没有，就会阻塞住渲染流程直到 JS 执行完毕。遇到文件下载的会去下载文件，这里如果使用 HTTP 2.0 协议的话会极大的提高多图的下载效率。

8. 初始的 HTML 被完全加载和解析后会触发 DOMContentLoaded 事件

9.  CSSOM 树和 DOM 树构建完成后会开始合并生成 Render 树，这一步就是确定页面元素的布局（回流）、样式等等诸多方面的东西

10. 在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上了

## 回流 reflow

当元素的尺寸或者位置发生了变化，就需要重新计算渲染树

- 触发：

  - DOM元素的几何属性(width/height/padding/margin/border)发生变化
  - DOM元素移动或增加
  - 读写offset/scroll/client等属性
  - 调用window.getComputedStyle

- 减少：

  - 使用 transform 替代 top
  - 使用class替代style，减少style的使用
  - 使用resize、scroll时进行防抖和节流处理，这两者会直接导致回流
  - 使用visibility替换display: none，因为前者只会引起重绘，后者会引发回流
  - 不要把节点的属性值放在一个循环里当成循环里的变量
  - 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局
  - 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame
  - CSS 选择符从右往左匹配查找，避免节点层级过多
  - 批量修改元素时，可以先让元素脱离文档流，等修改完毕后，再放入文档流
  - 避免触发同步布局事件
  - 对于复杂动画效果,使用绝对定位让其脱离文档流

## 重绘 repaint

DOM样式发生了变化，但没有影响DOM的几何属性时，会触发重绘，而不会触发回流

重绘由于DOM位置信息不需要更新，省去了布局过程，因而性能上优于回流

## 合成 composite
在 DOM 树中每个节点都会对应一个 LayoutObject，当他们的 LayoutObject 处于相同的坐标空间时，就会形成一个 RenderLayers ，也就是渲染层。RenderLayers 来保证页面元素以正确的顺序合成，这时候就会出现层合成（composite），从而正确处理透明元素和重叠元素的显示

提升合成层的最好方式是使用 CSS 的 will-change 属性。而 will-change 设置为 opacity、transform、top、left、bottom、right 可以将元素提升为合成层。
video、iframe 标签也可以可以生成新图层

## GPU加速

- 数据处理过程：

  - 将每个复合层绘制成一个单独的图像；
  - 准备层数据（尺寸、偏移量、透明度等）；
  - 准备动画着色器（如果适用）；
  - 将数据发送到GPU

- 优点：使用transform、opacity、filters等属性时，会直接在GPU中完成处理，这些属性的变化不会引起回流重绘

- 缺点：GPU渲染字体会导致字体模糊，过多的GPU处理会导致内存问题

## 事件触发

事件触发有三个阶段：

  1. window 往事件触发处传播，遇到注册的捕获事件会触发
  2. 传播到事件触发处时触发注册的事件
  3. 从事件触发处往 window 传播，遇到注册的冒泡事件会触发

捕获的流程为：window -> document -> html -> body -> ... -> 目标元素。

冒泡的流程为：目标元素 -> ... -> body -> html -> document -> window。

## 事件代理

如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上

事件代理的方式相对于直接给目标注册事件来说，有以下优点

  1. 节省内存
  2. 不需要给子节点注销事件

## 存储

cookie，localStorage，sessionStorage，indexDB

|  特性  |  cookie  |  localStorage   |  sessionStorage  |  indexDB   |
|  ----  |  ----  |  ----  |  ----  |  ----  |
| 数据生命周期  |  一般由服务器生成，可以设置过期时间 |  除非被清理，否则一直存在  |  页面关闭就清理  |  除非被清理，否则一直存在  |
| 数据存储大小  |  4K  |  5M  |  5M  |  无限  |
| 与服务端通信  |  每次都会携带在 header 中，对于请求性能影响  |  不参与  |  不参与  |  不参与  |

- 从上表可以看到，cookie 已经不建议用于存储。
- 如果没有大量数据存储需求的话，可以使用 localStorage 和 sessionStorage 。
- 对于不怎么改变的数据尽量使用 localStorage 存储，否则可以用 sessionStorage 存储

对于 cookie，我们还需要注意安全性：

|  属性  |  作用  |
|  ----  |  ----  |
|  value  |  如果用于保存用户登录态，应该将该值加密，不能使用明文的用户标识  |
|  http-only  |  不能通过 JS 访问 Cookie，减少 XSS 攻击  |
|  secure  |  只能在协议为 HTTPS 的请求中携带  |
|  same-site  |  规定浏览器不能在跨域请求中携带 Cookie，减少 CSRF 攻击  |
