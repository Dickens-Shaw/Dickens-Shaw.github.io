<!--
 * @Author: Shaw
 * @Date: 2021-06-15 14:40:04
 * @Description: 闭包
 * @LastEditors: Shaw
 * @LastEditTime: 2021-06-30 14:12:41
-->

## 数据类型

> JavaScript 共有七种基本数据类型，分别是 Undefined、Null、Boolean、Number、String，还有在 ES6 中新增的 Symbol 和 BigInt 类型

- Symbol 代表创建后独一无二且不可变的数据类型，它的出现我认为主要是为了解决可能出现的全局变量冲突的问题。
- BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。

这些数据可以分为原始数据类型和引用数据类型：

- 栈：原始数据类型（Undefined、Null、Boolean、Number、String）
- 堆：引用数据类型（对象、数组和函数）

两种类型的区别是：存储位置不同。

- 原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。
- 引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。

堆和栈的概念存在于数据结构中和操作系统内存中：

- 在数据结构中，栈中数据的存取方式为先进后出。
- 堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。完全二叉树是堆的一种实现方式。

## 闭包

> 红宝书：闭包是指有权访问另外一个函数作用域中的变量的函数
>
> MDN： 闭包是指那些能够访问自由变量的函数

自由变量：在函数中使用的，但既不是函数参数 arguments 也不是函数的局部变量的变量，其实就是另外一个函数作用域中的变量

函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包

所有的函数都是闭包，因为有全局环境，所有的函数都可以访问全局变量

意义：让我们可以间接访问函数内部的变量

特性：

1. 闭包可以访问当前函数以外的变量
2. 即使外部函数已经返回，闭包仍能访问外部函数定义的变量
3. 闭包可以更新外部变量的值

## 作用域、作用域链

> 作用域：指的是一个变量和函数的作用范围，JS 中函数内声明的所有变量在函数体内始终是可见的，在 ES6 前有全局作用域和局部作用域，但是没有块级作用域（catch 只在其内部生效），局部变量的优先级高于全局变量
>
> 作用域链：当访问一个变量时，解释器会首先在当前作用域查找标示符，如果没有找到，就去父作用域找，直到找到该变量的标示符或者不在父作用域中，这就是作用域链

## 原型、原型链

> 原型：当构造函数被创建时，会在内存空间新建一个对象，构造函数内有一个属性 prototype 会指向这个对象的存储空间，这个对象称为构造函数的原型对象

除了 Function.prototype.bind()之外每个函数都有 prototype 属性就是原型，原型的 constructor 属性指向构造函数，构造函数又通过 prototype 属性指回原型

> 原型链：每个对象拥有一个原型对象，通过 **proto** 指针指向上一个原型 ，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向 null，这种关系被称为原型链 (prototype chain)

1. Object 是所有对象的爸爸，所有对象都可以通过 **proto** 找到它
2. Function 是所有函数的爸爸，所有函数都可以通过 **proto** 找到它
3. Function.prototype 和 Object.prototype 是两个特殊的对象，他们由引擎来创建
4. 除了以上两个特殊对象，其他对象都是通过构造器 new 出来的

![blockchain](../_media/js/prototype.png)
