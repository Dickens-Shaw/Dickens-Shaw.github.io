<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress [object Promise]">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <title>工程化 | Shaw</title><meta name="description" content="这是我的第一个 VuePress 站点">
    <link rel="modulepreload" href="/assets/engineering.html.9a633182.js"><link rel="modulepreload" href="/assets/engineering.html.cd482ee7.js"><link rel="prefetch" href="/assets/index.html.93a9cfaa.js"><link rel="prefetch" href="/assets/browser.html.a54b332a.js"><link rel="prefetch" href="/assets/data.html.4ba0a106.js"><link rel="prefetch" href="/assets/design.html.28cf13ae.js"><link rel="prefetch" href="/assets/network.html.bd0988dd.js"><link rel="prefetch" href="/assets/typescript.html.198f7fc9.js"><link rel="prefetch" href="/assets/async.html.88b18e22.js"><link rel="prefetch" href="/assets/css.html.ed9b5713.js"><link rel="prefetch" href="/assets/es6.html.55944a4a.js"><link rel="prefetch" href="/assets/eventLoop.html.9d82381c.js"><link rel="prefetch" href="/assets/js.html.7b6826f4.js"><link rel="prefetch" href="/assets/formatter.html.f361f7b8.js"><link rel="prefetch" href="/assets/juejin.html.d01502c9.js"><link rel="prefetch" href="/assets/wechat.html.669c1514.js"><link rel="prefetch" href="/assets/common.html.c1193a10.js"><link rel="prefetch" href="/assets/react.html.73d3be5a.js"><link rel="prefetch" href="/assets/vue.html.5e84b882.js"><link rel="prefetch" href="/assets/cross.html.6ad7ed6e.js"><link rel="prefetch" href="/assets/lowcode.html.30869335.js"><link rel="prefetch" href="/assets/micro.html.bc38576d.js"><link rel="prefetch" href="/assets/optimize.html.7d2957ee.js"><link rel="prefetch" href="/assets/404.html.265028f6.js"><link rel="prefetch" href="/assets/index.html.46a6b8bc.js"><link rel="prefetch" href="/assets/browser.html.8c33f778.js"><link rel="prefetch" href="/assets/data.html.5e391979.js"><link rel="prefetch" href="/assets/design.html.05fbc41e.js"><link rel="prefetch" href="/assets/network.html.726d20fb.js"><link rel="prefetch" href="/assets/typescript.html.ed035233.js"><link rel="prefetch" href="/assets/async.html.42c6a6ce.js"><link rel="prefetch" href="/assets/css.html.f47d2209.js"><link rel="prefetch" href="/assets/es6.html.600c402e.js"><link rel="prefetch" href="/assets/eventLoop.html.84b2ee43.js"><link rel="prefetch" href="/assets/js.html.b2689a6b.js"><link rel="prefetch" href="/assets/formatter.html.eade2199.js"><link rel="prefetch" href="/assets/juejin.html.5a786eb6.js"><link rel="prefetch" href="/assets/wechat.html.c2018222.js"><link rel="prefetch" href="/assets/common.html.22c60bf3.js"><link rel="prefetch" href="/assets/react.html.5fd9c318.js"><link rel="prefetch" href="/assets/vue.html.778d5636.js"><link rel="prefetch" href="/assets/cross.html.56a9eec3.js"><link rel="prefetch" href="/assets/lowcode.html.330655e1.js"><link rel="prefetch" href="/assets/micro.html.545c727b.js"><link rel="prefetch" href="/assets/optimize.html.a22168f9.js"><link rel="prefetch" href="/assets/404.html.973816a9.js"><link rel="prefetch" href="/assets/404.2da2d90e.js"><link rel="prefetch" href="/assets/Layout.f17195d2.js">
    <link rel="stylesheet" href="/assets/style.95e11607.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/" class=""><img class="logo" src="/images/logo.jpeg" alt="Shaw"><span class="site-name can-hide">Shaw</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="基础"><span class="title">基础</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="基础"><span class="title">基础</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/basic/css" class="" aria-label="CSS基础"><!--[--><!--]--> CSS基础 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/basic/js" class="" aria-label="JS基础"><!--[--><!--]--> JS基础 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/basic/es6" class="" aria-label="ES6+"><!--[--><!--]--> ES6+ <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/basic/async" class="" aria-label="异步编程"><!--[--><!--]--> 异步编程 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/basic/eventLoop" class="" aria-label="事件循环"><!--[--><!--]--> 事件循环 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="进阶"><span class="title">进阶</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="进阶"><span class="title">进阶</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/advance/browser" class="" aria-label="浏览器"><!--[--><!--]--> 浏览器 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/advance/network" class="" aria-label="网络"><!--[--><!--]--> 网络 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/advance/typescript" class="" aria-label="TS"><!--[--><!--]--> TS <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/advance/design" class="" aria-label="设计模式"><!--[--><!--]--> 设计模式 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/advance/data" class="" aria-label="数据结构&amp;算法"><!--[--><!--]--> 数据结构&amp;算法 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="框架"><span class="title">框架</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="框架"><span class="title">框架</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/frame/common" class="" aria-label="MVVM"><!--[--><!--]--> MVVM <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/frame/react" class="" aria-label="React"><!--[--><!--]--> React <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/frame/vue" class="" aria-label="Vue"><!--[--><!--]--> Vue <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="架构"><span class="title">架构</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="架构"><span class="title">架构</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/architecture/optimize" class="" aria-label="项目优化"><!--[--><!--]--> 项目优化 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/architecture/engineering" class="router-link-active" aria-label="工程化"><!--[--><!--]--> 工程化 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/architecture/micro" class="" aria-label="微前端"><!--[--><!--]--> 微前端 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/architecture/cross" class="" aria-label="大前端"><!--[--><!--]--> 大前端 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/architecture/lowcode" class="" aria-label="低代码"><!--[--><!--]--> 低代码 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="收藏夹"><span class="title">收藏夹</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="收藏夹"><span class="title">收藏夹</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/bookmark/juejin" class="" aria-label="掘金"><!--[--><!--]--> 掘金 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/bookmark/wechat" class="" aria-label="微信"><!--[--><!--]--> 微信 <!--[--><!--]--></a></li><!--]--></ul></div></div><!--]--></nav><!--[--><!--]--><button class="toggle-color-mode-button" title="toggle color mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><form class="search-box" role="search"><input type="search" placeholder="搜索" autocomplete="off" spellcheck="false" value><!----></form></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="基础"><span class="title">基础</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="基础"><span class="title">基础</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/basic/css" class="" aria-label="CSS基础"><!--[--><!--]--> CSS基础 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/basic/js" class="" aria-label="JS基础"><!--[--><!--]--> JS基础 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/basic/es6" class="" aria-label="ES6+"><!--[--><!--]--> ES6+ <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/basic/async" class="" aria-label="异步编程"><!--[--><!--]--> 异步编程 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/basic/eventLoop" class="" aria-label="事件循环"><!--[--><!--]--> 事件循环 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="进阶"><span class="title">进阶</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="进阶"><span class="title">进阶</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/advance/browser" class="" aria-label="浏览器"><!--[--><!--]--> 浏览器 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/advance/network" class="" aria-label="网络"><!--[--><!--]--> 网络 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/advance/typescript" class="" aria-label="TS"><!--[--><!--]--> TS <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/advance/design" class="" aria-label="设计模式"><!--[--><!--]--> 设计模式 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/advance/data" class="" aria-label="数据结构&amp;算法"><!--[--><!--]--> 数据结构&amp;算法 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="框架"><span class="title">框架</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="框架"><span class="title">框架</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/frame/common" class="" aria-label="MVVM"><!--[--><!--]--> MVVM <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/frame/react" class="" aria-label="React"><!--[--><!--]--> React <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/frame/vue" class="" aria-label="Vue"><!--[--><!--]--> Vue <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="架构"><span class="title">架构</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="架构"><span class="title">架构</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/architecture/optimize" class="" aria-label="项目优化"><!--[--><!--]--> 项目优化 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/architecture/engineering" class="router-link-active" aria-label="工程化"><!--[--><!--]--> 工程化 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/architecture/micro" class="" aria-label="微前端"><!--[--><!--]--> 微前端 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/architecture/cross" class="" aria-label="大前端"><!--[--><!--]--> 大前端 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/architecture/lowcode" class="" aria-label="低代码"><!--[--><!--]--> 低代码 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="收藏夹"><span class="title">收藏夹</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="收藏夹"><span class="title">收藏夹</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/bookmark/juejin" class="" aria-label="掘金"><!--[--><!--]--> 掘金 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/bookmark/wechat" class="" aria-label="微信"><!--[--><!--]--> 微信 <!--[--><!--]--></a></li><!--]--></ul></div></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading active">前端架构 <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a href="/architecture/optimize.html" class="sidebar-item" aria-label="优化"><!--[--><!--]--> 优化 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/architecture/engineering.html" class="router-link-active router-link-exact-active router-link-active sidebar-item active" aria-label="工程化"><!--[--><!--]--> 工程化 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/architecture/engineering.html#概念" class="router-link-active router-link-exact-active sidebar-item" aria-label="概念"><!--[--><!--]--> 概念 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/architecture/engineering.html#git-hook-在项目中的作用" class="router-link-active router-link-exact-active sidebar-item" aria-label="Git Hook 在项目中的作用"><!--[--><!--]--> Git Hook 在项目中的作用 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/architecture/engineering.html#git-hook-常用的钩子" class="router-link-active router-link-exact-active sidebar-item" aria-label="Git Hook 常用的钩子"><!--[--><!--]--> Git Hook 常用的钩子 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/architecture/engineering.html#核心概念" class="router-link-active router-link-exact-active sidebar-item" aria-label="核心概念"><!--[--><!--]--> 核心概念 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/architecture/engineering.html#构建流程" class="router-link-active router-link-exact-active sidebar-item" aria-label="构建流程"><!--[--><!--]--> 构建流程 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/architecture/engineering.html#loader" class="router-link-active router-link-exact-active sidebar-item" aria-label="Loader"><!--[--><!--]--> Loader <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/architecture/engineering.html#特点" class="router-link-active router-link-exact-active sidebar-item" aria-label="特点"><!--[--><!--]--> 特点 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/architecture/engineering.html#代码结构" class="router-link-active router-link-exact-active sidebar-item" aria-label="代码结构"><!--[--><!--]--> 代码结构 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/architecture/engineering.html#类型" class="router-link-active router-link-exact-active sidebar-item" aria-label="类型"><!--[--><!--]--> 类型 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/architecture/engineering.html#api" class="router-link-active router-link-exact-active sidebar-item" aria-label="API"><!--[--><!--]--> API <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/architecture/engineering.html#常用-loader" class="router-link-active router-link-exact-active sidebar-item" aria-label="常用 loader"><!--[--><!--]--> 常用 loader <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/architecture/engineering.html#plugin" class="router-link-active router-link-exact-active sidebar-item" aria-label="Plugin"><!--[--><!--]--> Plugin <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/architecture/engineering.html#基本结构" class="router-link-active router-link-exact-active sidebar-item" aria-label="基本结构"><!--[--><!--]--> 基本结构 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/architecture/engineering.html#compiler-and-compilation" class="router-link-active router-link-exact-active sidebar-item" aria-label="Compiler and Compilation"><!--[--><!--]--> Compiler and Compilation <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/architecture/engineering.html#同步与异步" class="router-link-active router-link-exact-active sidebar-item" aria-label="同步与异步"><!--[--><!--]--> 同步与异步 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/architecture/engineering.html#常用的-plugin" class="router-link-active router-link-exact-active sidebar-item" aria-label="常用的 plugin"><!--[--><!--]--> 常用的 plugin <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/architecture/engineering.html#动态加载" class="router-link-active router-link-exact-active sidebar-item" aria-label="动态加载"><!--[--><!--]--> 动态加载 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/architecture/engineering.html#babel-原理" class="router-link-active router-link-exact-active sidebar-item" aria-label="Babel 原理"><!--[--><!--]--> Babel 原理 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/architecture/engineering.html#热跟新原理" class="router-link-active router-link-exact-active sidebar-item" aria-label="热跟新原理"><!--[--><!--]--> 热跟新原理 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/architecture/engineering.html#tree-shaking" class="router-link-active router-link-exact-active sidebar-item" aria-label="Tree Shaking"><!--[--><!--]--> Tree Shaking <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/architecture/engineering.html#在-webpack-中启动-tree-shaking" class="router-link-active router-link-exact-active sidebar-item" aria-label="在 Webpack 中启动 Tree Shaking"><!--[--><!--]--> 在 Webpack 中启动 Tree Shaking <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/architecture/engineering.html#理论基础" class="router-link-active router-link-exact-active sidebar-item" aria-label="理论基础"><!--[--><!--]--> 理论基础 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/architecture/engineering.html#实现原理" class="router-link-active router-link-exact-active sidebar-item" aria-label="实现原理"><!--[--><!--]--> 实现原理 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/architecture/engineering.html#优化打包速度" class="router-link-active router-link-exact-active sidebar-item" aria-label="优化打包速度"><!--[--><!--]--> 优化打包速度 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/architecture/engineering.html#优化项目" class="router-link-active router-link-exact-active sidebar-item" aria-label="优化项目"><!--[--><!--]--> 优化项目 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/architecture/engineering.html#构建流程-1" class="router-link-active router-link-exact-active sidebar-item" aria-label="构建流程"><!--[--><!--]--> 构建流程 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/architecture/engineering.html#核心概念-1" class="router-link-active router-link-exact-active sidebar-item" aria-label="核心概念"><!--[--><!--]--> 核心概念 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/architecture/engineering.html#配置" class="router-link-active router-link-exact-active sidebar-item" aria-label="配置"><!--[--><!--]--> 配置 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/architecture/engineering.html#单元测试" class="router-link-active router-link-exact-active sidebar-item" aria-label="单元测试"><!--[--><!--]--> 单元测试 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/architecture/engineering.html#组件测试" class="router-link-active router-link-exact-active sidebar-item" aria-label="组件测试"><!--[--><!--]--> 组件测试 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/architecture/engineering.html#e2e-测试" class="router-link-active router-link-exact-active sidebar-item" aria-label="e2e 测试"><!--[--><!--]--> e2e 测试 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/architecture/engineering.html#脚手架" class="router-link-active router-link-exact-active sidebar-item" aria-label="脚手架"><!--[--><!--]--> 脚手架 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/architecture/engineering.html#组件库" class="router-link-active router-link-exact-active sidebar-item" aria-label="组件库"><!--[--><!--]--> 组件库 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/architecture/engineering.html#npm-run" class="router-link-active router-link-exact-active sidebar-item" aria-label="npm run ***"><!--[--><!--]--> npm run *** <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a href="/architecture/micro.html" class="sidebar-item" aria-label="微前端"><!--[--><!--]--> 微前端 <!--[--><!--]--></a><!----></li><li><a href="/architecture/cross.html" class="sidebar-item" aria-label="大前端"><!--[--><!--]--> 大前端 <!--[--><!--]--></a><!----></li><li><a href="/architecture/lowcode.html" class="sidebar-item" aria-label="低代码"><!--[--><!--]--> 低代码 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><h1 id="工程化" tabindex="-1"><a class="header-anchor" href="#工程化" aria-hidden="true">#</a> 工程化</h1><h2 id="概念" tabindex="-1"><a class="header-anchor" href="#概念" aria-hidden="true">#</a> 概念</h2><blockquote><p>工程化是一种思想，而不是某种技术。其主要目的为了提高效率和降低成本，即提高开发过程中的开发效率，减少不必要的重复工作时间等</p></blockquote><ul><li><p>模块化</p><p>模块化就是把一个大的文件，拆分成多个相互依赖的小文件，按一个个模块来划分</p></li><li><p>组件化</p><p>页面上所有的东西都可以看成组件，页面是个大型组件，可以拆成若干个中型组件，然后中型组件还可以再拆，拆成若干个小型组件</p><p>组件化 ≠ 模块化。模块化只是在文件层面上，对代码和资源的拆分；组件化是在设计层面上，对于 UI 的拆分 目前市场上的组件化的框架，主要的有 Vue，React，Angular2</p></li><li><p>规范化</p><p>在项目规划初期制定的好坏对于后期的开发有一定影响。包括的规范有</p><ul><li>目录结构的制定</li><li>编码规范</li><li>前后端接口规范</li><li>文档规范</li><li>组件管理</li><li>Git 分支管理</li><li>Commit 描述规范</li><li>定期 codeReview</li><li>视觉图标规范</li></ul></li><li><p>自动化</p><p>也就是简单重复的工作交给机器来做，自动化也就是有很多自动化工具代替我们来完成，例如持续集成、自动化构建、自动化部署、自动化测试等等</p></li></ul><h1 id="git" tabindex="-1"><a class="header-anchor" href="#git" aria-hidden="true">#</a> Git</h1><h2 id="git-hook-在项目中的作用" tabindex="-1"><a class="header-anchor" href="#git-hook-在项目中的作用" aria-hidden="true">#</a> Git Hook 在项目中的作用</h2><ul><li>多人开发代码语法、规范强制统一</li><li>commit message 格式化、是否符合某种规范</li><li>如果有需要，测试用例的检测</li><li>服务器代码有新的更新的时候通知所有开发成员</li><li>代码提交后的项目自动打包（git receive 之后）</li></ul><h2 id="git-hook-常用的钩子" tabindex="-1"><a class="header-anchor" href="#git-hook-常用的钩子" aria-hidden="true">#</a> Git Hook 常用的钩子</h2><ol><li>ClientSide hooks：</li></ol><ul><li>pre-commit，当执行 commit 动作时先执行此 hook，可以用此 hook 做一些检查，比如代码风格检查，或者先跑测试。</li><li>prepare-commit-msg， 当 commit 时需要输入 message 前会触发此 hook，可以用此 hook 来定制自己的 default message 信息。</li><li>commit-msg，当用户输入 commit 的 message 后被触发，可以用此 hook 校验 message 的信息，比如是否符合规定，有没有 cr 等。</li><li>post-commit, 当 commit 完成后被触发，可以用此 hook 发送 notification 等。</li><li>pre-rebase, rebase 之前会被触发，可以用此 hook 来拒绝所有的已经 push 的 commits 进行 rebase 操作。</li><li>post-merge, 当 merge 成功后，会触发此 hook。</li><li>pre-push, 当 push 时，remote refs 被更新，但是在所有的 objects 传输前被触发。</li><li>pre-auto-gc, 当 git gc –auto 执行前被触发。在垃圾回收之前做一些验证或备份是挺不错的。</li></ul><ol start="2"><li>ServerSide hooks:</li></ol><ul><li>pre-receive, 当收到 push 动作之前会被执行。</li><li>update, 也是收到 push 动作之前被执行，但是有可能被执行多次，每个 branch 一次。</li><li>post-receive, 当 push 动作已经完成的时候会被触发，可以用此 hook 来 push notification 等，比如发邮件，通知持续构建服务器等。</li></ul><h1 id="webpack" tabindex="-1"><a class="header-anchor" href="#webpack" aria-hidden="true">#</a> Webpack</h1><p>一个用于现代 JavaScript 应用程序的 静态模块打包工具。当 webpack 处理应用程序时，它会在内部从一个或多个入口点构建一个 依赖图(<code>dependency graph</code>)，然后将你项目中所需的每一个模块组合成一个或多个 <code>bundles</code>，它们均为静态资源，用于展示你的内容。</p><p>作用：代码分割、文件压缩合并、编译兼容、模块合并、高级语法翻译、按需加载、代码校验、自动刷新、模块热替换、Tree Shaking</p><h2 id="核心概念" tabindex="-1"><a class="header-anchor" href="#核心概念" aria-hidden="true">#</a> 核心概念</h2><ul><li>Entry：入口，指示 Webpack 应该使用哪个模块，来作为构建其内部 依赖图(dependency graph) 的开始。</li><li>Output：输出结果，告诉 Webpack 在哪里输出它所创建的 bundle，以及如何命名这些文件。</li><li>Module：模块，在 Webpack 里一切皆模块，一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。</li><li>Chunk：代码块，一个 Chunk 由多个模块组合而成，用于代码合并与分割。</li><li>Loader：模块代码转换器，让 webpack 能够去处理除了 JS、JSON 之外的其他类型的文件，并将它们转换为有效 模块，以供应用程序使用，以及被添加到依赖图中。</li><li>Plugin：扩展插件。在 webpack 运行的生命周期中会广播出许多事件，plugin 可以监听这些事件，在合适的时机通过 webpack 提供的 api 改变输出结果。常见的有：打包优化，资源管理，注入环境变量。</li><li>Mode：模式，告知 webpack 使用相应模式的内置优化</li><li>Browser Compatibility：浏览器兼容性，Webpack 支持所有符合 ES5 标准 的浏览器（IE8 以上版本）</li></ul><h2 id="构建流程" tabindex="-1"><a class="header-anchor" href="#构建流程" aria-hidden="true">#</a> 构建流程</h2><ul><li>初始化参数： 从配置文件和 Shell 语句中读取与合并参数，得到最终的参数</li><li>开始编译： 用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译</li><li>确定入口： 根据配置中的 entry 找到所有的入口文件</li><li>编译模块： 从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。</li><li>完成模块编译： 在经过第 4 步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系。</li><li>输出资源： 根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk, 再把每个 Chunk 转换为一个单独的文件加载到输出列表，这步是可以修改输出内容的最后机会。</li><li>输出完成： 在确定好输出内容后，根据 output 配置确定输出的路径和文件名，把文件内容写入文件系统。</li></ul><p>简单说：</p><ul><li>初始化： 从启动构建，读取与合并配置参数，加载 Plugin， 实例化 Compiler</li><li>编译： 从 Entry 出发，针对每个 Module 串行调用对应的 Loader 去翻译文件的内容，再找到该 Module 依赖的 Module ，递归地进行编译处理</li><li>输出： 将编译后的 Module 组合成 Chunk，将 Chunk 转换成文件，输出到文件系统中。</li></ul><h2 id="loader" tabindex="-1"><a class="header-anchor" href="#loader" aria-hidden="true">#</a> Loader</h2><blockquote><p>webpack 中提供了一种处理多种文件格式的机制，这便是 Loader，我们可以把 Loader 当成一个转换器，它可以将某种格式的文件转换成 webpack 支持打包的模块。</p></blockquote><p>在 Webpack 中，一切皆模块，我们常见的 Javascript、CSS、Less、Typescript、Jsx、图片等文件都是模块，不同模块的加载是通过模块加载器来统一管理的，当我们需要使用不同的 Loader 来解析不同类型的文件时，我们可以在 module.rules 字段下配置相关规则：</p><ul><li>test 属性，识别出哪些文件会被转换。</li><li>use 属性，定义出在进行转换时，应该使用哪个 loader。</li></ul><h3 id="特点" tabindex="-1"><a class="header-anchor" href="#特点" aria-hidden="true">#</a> 特点</h3><ul><li>loader 本质上是一个函数，output=loader(input) // input 可为工程源文件的字符串，也可是上一个 loader 转化后的结果；</li><li>第一个 loader 的传入参数只有一个：资源文件(resource file)的内容；</li><li>loader 支持链式调用，webpack 打包时是按照数组从后往前的顺序将资源交给 loader 处理的。</li><li>支持同步或异步函数。</li></ul><h3 id="代码结构" tabindex="-1"><a class="header-anchor" href="#代码结构" aria-hidden="true">#</a> 代码结构</h3><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// source：资源输入，对于第一个执行的 loader 为资源文件的内容；后续执行的 loader 则为前一个 loader 的执行结果</span>
<span class="token comment">// sourceMap: 可选参数，代码的 sourcemap 结构</span>
<span class="token comment">// data: 可选参数，其它需要在 Loader 链中传递的信息，比如 posthtml/posthtml-loader 就会通过这个参数传递参数的 AST 对象</span>
<span class="token keyword">const</span> loaderUtils <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;loader-utils&#39;</span><span class="token punctuation">)</span>
module<span class="token punctuation">.</span><span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">source<span class="token punctuation">,</span> sourceMap<span class="token operator">?</span><span class="token punctuation">,</span> data<span class="token operator">?</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 获取到用户给当前 Loader 传入的 options</span>
  <span class="token keyword">const</span> options <span class="token operator">=</span> loaderUtils<span class="token punctuation">.</span><span class="token function">getOptions</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token comment">// TODO： 此处为转换source的逻辑</span>
  <span class="token keyword">return</span> source
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="类型" tabindex="-1"><a class="header-anchor" href="#类型" aria-hidden="true">#</a> 类型</h3><ol><li>同步 loader：</li></ol><p>一般的 loader 转换都是同步的，我们可以采用上面说的直接 return 结果的方式，返回我们的处理结果：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>module<span class="token punctuation">.</span><span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">source</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 对 source 进行一些处理</span>
  <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token function">doSomething</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span>
  <span class="token keyword">return</span> res
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也可以直接使用 <code>this.callback()</code> 这个 api，然后在最后直接 <strong>return undefined</strong> 的方式告诉 webpack 去 <code>this.callback()</code> 寻找他要的结果，这个 api 接受这些参数：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">callback</span><span class="token punctuation">(</span>
  <span class="token literal-property property">err</span><span class="token operator">:</span> Error <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token comment">// 一个无法正常编译时的 Error 或者 直接给个 null</span>
  <span class="token literal-property property">content</span><span class="token operator">:</span> string <span class="token operator">|</span> Buffer<span class="token punctuation">,</span><span class="token comment">// 我们处理后返回的内容 可以是 string 或者 Buffer（）</span>
  sourceMap<span class="token operator">?</span><span class="token operator">:</span> SourceMap<span class="token punctuation">,</span> <span class="token comment">// 可选 可以是一个被正常解析的 source map</span>
  meta<span class="token operator">?</span><span class="token operator">:</span> any <span class="token comment">// 可选 可以是任何东西，比如一个公用的 AST 语法树</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>例：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>module<span class="token punctuation">.</span><span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">content</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 获取到用户传给当前 loader 的参数</span>
  <span class="token keyword">const</span> options <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getOptions</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token function">someSyncOperation</span><span class="token punctuation">(</span>content<span class="token punctuation">,</span> options<span class="token punctuation">)</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">callback</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> res<span class="token punctuation">,</span> sourceMaps<span class="token punctuation">)</span>
  <span class="token comment">// 注意这里由于使用了 this.callback 直接 return 就行</span>
  <span class="token keyword">return</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><em>*从 webpack 5 开始，this.getOptions 可以获取到 loader 上下文对象</em></p><ol start="2"><li>异步 loader：</li></ol><p>当我们遇到譬如需要网络请求等场景，那么为了避免阻塞构建步骤，我们会采取异步构建的方式，异步 loader 可以使用 <code>this.async()</code> 方法来告知 webpack 这次构建操作是异步的：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>module<span class="token punctuation">.</span><span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">content</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> callback <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">async</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token function">someAsyncOperation</span><span class="token punctuation">(</span>content<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> result</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">callback</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
    <span class="token function">callback</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> result<span class="token punctuation">,</span> sourceMaps<span class="token punctuation">,</span> meta<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>Raw loader： 默认情况下，资源文件会被转化为 UTF-8 字符串，然后传给 loader。通过设置 raw 为 true，loader 可以接收原始的 Buffer。每一个 loader 都可以用 String 或者 Buffer 的形式传递它的处理结果。complier 将会把它们在 loader 之间相互转换。大家熟悉的 <code>file-loader</code> 就是用了这个。</li></ol><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>module<span class="token punctuation">.</span><span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">content</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>content <span class="token keyword">instanceof</span> <span class="token class-name">Buffer</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
  <span class="token keyword">return</span> <span class="token function">doSomeOperation</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

module<span class="token punctuation">.</span>exports<span class="token punctuation">.</span>raw <span class="token operator">=</span> <span class="token boolean">true</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4"><li>Pitching loader：</li></ol><p>loader 是按照从右往左的顺序被调用的，但是实际上，在此之前会有一个按照从左往右执行每一个 loader 的 pitch 方法的过程。 pitch 方法共有三个参数：</p><ul><li>remainingRequest：loader 链中排在自己后面的 loader 以及资源文件的绝对路径以!作为连接符组成的字符串。</li><li>precedingRequest：loader 链中排在自己前面的 loader 的绝对路径以!作为连接符组成的字符串。</li><li>data：每个 loader 中存放在上下文中的固定字段，可用于 pitch 给 loader 传递数据。</li></ul><p>在 pitch 中传给 data 的数据，在后续的调用执行阶段，是可以在 <code>this.data</code> 中获取到的：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>module<span class="token punctuation">.</span><span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">content</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">someSyncOperation</span><span class="token punctuation">(</span>content<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// 这里的 this.data.value === 42</span>
<span class="token punctuation">}</span>

module<span class="token punctuation">.</span>exports<span class="token punctuation">.</span><span class="token function-variable function">pitch</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">remainingRequest<span class="token punctuation">,</span> precedingRequest<span class="token punctuation">,</span> data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  data<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token number">42</span>
  <span class="token comment">// return 如果某一个 loader 的 pitch 方法中返回了值，那么他会直接跳过后续的步骤</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="api" tabindex="-1"><a class="header-anchor" href="#api" aria-hidden="true">#</a> API</h3><ul><li>this.addDependency：加入一个文件进行监听，一旦文件产生变化就会重新调用这个 loader 进行处理</li><li>this.cacheable：默认情况下 loader 的处理结果会有缓存效果，给这个方法传入 false 可以关闭这个效果</li><li>this.clearDependencies：清除 loader 的所有依赖</li><li>this.context：文件所在的目录（不包含文件名）</li><li>this.data：pitch 阶段和正常调用阶段共享的对象</li><li>this.getOptions(schema)：用来获取配置的 loader 参数选项</li><li>this.resolve：像 require 表达式一样解析一个 <code>request。resolve(context: string, request: string, callback: function(err, result: string))</code></li><li>this.loaders：所有 loader 组成的数组。它在 pitch 阶段的时候是可以写入的。</li><li>this.resource：获取当前请求路径，包含参数：<code>&#39;/abc/resource.js?rrr&#39;</code></li><li>this.resourcePath：不包含参数的路径：<code>&#39;/abc/resource.js&#39;</code></li><li>this.sourceMap：bool 类型，是否应该生成一个 sourceMap</li></ul><h3 id="常用-loader" tabindex="-1"><a class="header-anchor" href="#常用-loader" aria-hidden="true">#</a> 常用 loader</h3><ul><li>babel-loader 中间桥梁，通过调用 babel/core 中的 api 来告诉 webpack 要如何处理 js</li><li>style-loader 负责把样式插入到 DOM 中，方法是在 head 中插入一个 style 标签，并把样式写入到这个标签的 innerHTML 里</li><li>css-loader 其中 css-loader 处理 js 中 import require() @import/url 引入的内容</li><li>sass-loader 把 scss 转成 css</li><li>less-loader 把 less 转成 css</li><li>postcss-loader 在 css 文件中使用 postcss 插件，比如 autoprefixer，cssnano 等</li><li>ts-loader 根据 tsconfig.json 的配置，自动编译 ts 文件</li><li>svg-sprite-loader 将 svg 图标打包成一个雪碧图，并且把雪碧图的内容插入到 html 中</li><li>markdown-loader 把 markdown 文件编译解析成 html 文件</li><li>raw-loader 将文件中的内容作为字符串导入，并插入到 html 中</li><li>file-loader 使得我们可以在 JS 文件中引入 png\jpg 等图片资源</li><li>url-loader 跟 file-loader 类似；唯一不同的是在于用户可以设置一个文件大小的阈值，当大于阈值时跟 file-loader 一样返回 publicPath，而小于该阈值时则返回文件 base64 形式编码。</li><li>thread-loader 可以让 webpack 在多个进程中并行执行 loader，提高打包速度。</li><li>cache-loader 在性能开销较大的 loader 之前添加此 loader，将结果缓存到磁盘里</li></ul><h2 id="plugin" tabindex="-1"><a class="header-anchor" href="#plugin" aria-hidden="true">#</a> Plugin</h2><blockquote><p>Webpack 就像一条生产线，要经过一系列处理流程后才能将源文件转换成输出结果。 这条生产线上的每个处理流程的职责都是单一的，多个流程之间有存在依赖关系，只有完成当前处理后才能交给下一个流程去处理。 插件就像是一个插入到生产线中的一个功能，在特定的时机对生产线上的资源做处理。</p></blockquote><blockquote><p>Plugin 就是插件，基于事件流框架 Tapable，插件可以扩展 Webpack 的功能，在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。Webpack 的事件流机制保证了插件的有序性，使得整个系统扩展性很好。</p></blockquote><h3 id="基本结构" tabindex="-1"><a class="header-anchor" href="#基本结构" aria-hidden="true">#</a> 基本结构</h3><ul><li>一个 JavaScript 命名函数或 JavaScript 类。</li><li>在插件函数的 prototype 上定义一个 apply 方法。</li><li>指定一个绑定到 webpack 自身的事件钩子。</li><li>处理 webpack 内部实例的特定数据。</li><li>功能完成后调用 webpack 提供的回调。</li></ul><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 一个 JavaScript 类</span>
<span class="token keyword">class</span> <span class="token class-name">HelloPlugin</span><span class="token punctuation">{</span>
  <span class="token comment">// 在插件函数的 prototype 上定义一个 `apply` 方法，以 compiler 为参数。</span>
  <span class="token function">apply</span><span class="token punctuation">(</span><span class="token parameter">compiler</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// 指定一个挂载到 webpack 自身的事件钩子。</span>
    compiler<span class="token operator">/</span>compilation<span class="token punctuation">.</span>hooks<span class="token punctuation">.</span><span class="token operator">&lt;</span>hookName<span class="token operator">&gt;</span><span class="token punctuation">.</span>tap<span class="token operator">/</span>tapAsync<span class="token operator">/</span><span class="token function">tapPromise</span><span class="token punctuation">(</span>PluginName<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token parameter">compilation<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;这是一个示例插件！&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>
        <span class="token string">&#39;这里表示了资源的单次构建的 `compilation` 对象：&#39;</span><span class="token punctuation">,</span>
        compilation
      <span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token comment">// 用 webpack 提供的插件 API 处理构建过程</span>
      compilation<span class="token punctuation">.</span><span class="token function">addModule</span><span class="token punctuation">(</span><span class="token comment">/* ... */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> HelloPlugin
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="compiler-and-compilation" tabindex="-1"><a class="header-anchor" href="#compiler-and-compilation" aria-hidden="true">#</a> Compiler and Compilation</h3><ul><li><p><code>compiler</code> 对象可以理解为一个和 webpack 环境整体绑定的一个对象，它包含了所有的环境配置，包括 options，loader 和 plugin，当 webpack 启动时，这个对象会被实例化，并且他是<strong>全局唯一</strong>的，上面我们说到的 apply 方法传入的参数就是它。</p></li><li><p><code>compilation</code> 在每次构建资源的过程中都会被创建出来，一个 compilation 对象表现了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态信息。它同样也提供了很多的 hook 。</p></li></ul><p>Compiler 和 Compilation 提供了非常多的钩子供我们使用，这些方法的组合可以让我们在构建过程的不同时间获取不同的内容。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">HelloCompilationPlugin</span> <span class="token punctuation">{</span>
  <span class="token function">apply</span><span class="token punctuation">(</span><span class="token parameter">compiler</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 指定一个挂载到 compilation 的钩子，回调函数的参数为 compilation 。</span>
    compiler<span class="token punctuation">.</span>hooks<span class="token punctuation">.</span>compilation<span class="token punctuation">.</span><span class="token function">tap</span><span class="token punctuation">(</span><span class="token string">&#39;HelloCompilationPlugin&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">compilation</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token comment">// 现在可以通过 compilation 对象绑定各种钩子</span>
      compilation<span class="token punctuation">.</span>hooks<span class="token punctuation">.</span>optimize<span class="token punctuation">.</span><span class="token function">tap</span><span class="token punctuation">(</span><span class="token string">&#39;HelloCompilationPlugin&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;资源已经优化完毕。&#39;</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> HelloCompilationPlugin
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="同步与异步" tabindex="-1"><a class="header-anchor" href="#同步与异步" aria-hidden="true">#</a> 同步与异步</h3><p>plugin 的 hooks 是有同步和异步区分的，在同步的情况下，我们使用 <code>&lt;hookName&gt;.tap</code> 的方式进行调用，而在异步 hook 内我们可以进行一些异步操作，并且有异步操作的情况下，请使用 <code>tapAsync</code> 或者 <code>tapPromise</code> 方法来告知 webpack 这里的内容是异步的</p><ul><li>tapAsync</li></ul><p>使用 <code>tapAsync</code> 的时候，我们需要多传入一个 <code>callback</code> 回调，并且在结束的时候一定要调用这个回调告知 webpack 这段异步操作结束了</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">HelloAsyncPlugin</span> <span class="token punctuation">{</span>
  <span class="token function">apply</span><span class="token punctuation">(</span><span class="token parameter">compiler</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    compiler<span class="token punctuation">.</span>hooks<span class="token punctuation">.</span>emit<span class="token punctuation">.</span><span class="token function">tapAsync</span><span class="token punctuation">(</span>
      <span class="token string">&#39;HelloAsyncPlugin&#39;</span><span class="token punctuation">,</span>
      <span class="token punctuation">(</span><span class="token parameter">compilation<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">// 执行某些异步操作...</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;异步任务完成...&#39;</span><span class="token punctuation">)</span>
          <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> HelloAsyncPlugin
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>tapPromise</li></ul><p>当使用 <code>tapPromise</code> 来处理异步的时候，我们需要返回一个 <code>Promise</code> 对象并且让它在结束的时候 <code>resolve</code></p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">HelloAsyncPlugin</span> <span class="token punctuation">{</span>
  <span class="token function">apply</span><span class="token punctuation">(</span><span class="token parameter">compiler</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    compiler<span class="token punctuation">.</span>hooks<span class="token punctuation">.</span>emit<span class="token punctuation">.</span><span class="token function">tapPromise</span><span class="token punctuation">(</span><span class="token string">&#39;HelloAsyncPlugin&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">compilation</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token comment">// 返回一个 promise ，异步任务完成后 resolve</span>
      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;异步任务完成...&#39;</span><span class="token punctuation">)</span>
          <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> HelloAsyncPlugin
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="常用的-plugin" tabindex="-1"><a class="header-anchor" href="#常用的-plugin" aria-hidden="true">#</a> 常用的 plugin</h3><ul><li>copy-webpack-plugin 将已存在的文件复制到指定目录</li><li>html-webpack-plugin 自动生成 HTML5 文件，并引入 webpack 打包好的 js 等文件。 <ul><li>单页应用可以生成一个 html 入口，多页应用可以配置多个 html-webpack-plugin 实例来生成多个页面入口</li><li>为 html 引入外部资源如 script、link，将 entry 配置的相关入口 chunk 以及 mini-css-extract-plugin 抽取的 css 文件插入到基于该插件设置的 template 文件生成的 html 文件里面，具体的方式是 link 插入到 head 中，script 插入到 head 或 body 中。</li></ul></li><li>clean-webpack-plugin 用于打包前先把 dist 文件夹清空，删除 webpack 的 output.path 中的所有文件，以及每次成功重新构建后所有未使用的资源</li><li>hot-module-replacement-plugin 模块热替换插件，即 HMR，webpack4 自带插件，无需安装，在开发模式下配合 devServer 使用 <ul><li>保留在完全重新加载页面期间丢失的应用程序状态。</li><li>只更新变更内容，以节省宝贵的开发时间。</li><li>在源代码中 CSS/JS 产生修改时，会立刻在浏览器中进行更新，这几乎相当于在浏览器 devtools 直接更改样式。</li></ul></li><li>mini-css-extract-plugin 将 CSS 提取到单独的文件中，为每个包含 CSS 的 JS 文件创建一个 CSS 文件</li><li>purge-css-plugin 可以去除未使用的 css, 一般与 glob、glob-all 配合使用。</li><li>optimize-css-assets-webpack-plugin 用于 CSS 压缩</li><li>split-chunks-plugin 用于提取 js 中公共代码。webpack4 内置插件。</li><li>webpack-bundle-analyzer 可视化 webpack 输出文件的体积，分析生成Bundle的每个模块体积大小</li><li>terser-webpack-plugin 用于处理 js 的压缩和混淆，开启多进程并行、缓存模式</li><li>speed-measure-webpack-plugin 分析每个loader和plugin执行耗时具体情况</li><li>hard-source-webpack-plugin 为模块提供中间缓存，快速提升二次构建的速度。</li></ul><h2 id="动态加载" tabindex="-1"><a class="header-anchor" href="#动态加载" aria-hidden="true">#</a> 动态加载</h2><p>import()和 require.ensure</p><p>原理：动态的创建 script 标签，以及通过 jsonp 去请求 chunk</p><h2 id="babel-原理" tabindex="-1"><a class="header-anchor" href="#babel-原理" aria-hidden="true">#</a> Babel 原理</h2><p>本质就是编译器，分为三步：</p><ol><li>词法分析生成 Token，语法分析生成 AST，</li><li>遍历 AST，根据插件变换相应的节点，</li><li>最后把 AST 转换为代码</li></ol><h2 id="热跟新原理" tabindex="-1"><a class="header-anchor" href="#热跟新原理" aria-hidden="true">#</a> 热跟新原理</h2><ol><li>当修改了一个或多个文件；</li><li>文件系统接收更改并通知 webpack；</li><li>webpack 重新编译构建一个或多个模块，并通知 HMR 服务器进行更新；</li><li>HMR Server 使用 webSocket 通知 HMR runtime 需要更新，HMR 运行时通过 HTTP 请求更新 jsonp；</li><li>HMR 运行时替换更新中的模块，如果确定这些模块无法更新，则触发整个页面刷新。</li></ol><h2 id="tree-shaking" tabindex="-1"><a class="header-anchor" href="#tree-shaking" aria-hidden="true">#</a> Tree Shaking</h2><p>Tree-Shaking 是一种基于 ES Module 规范的 Dead Code Elimination 技术，它会在运行过程中静态分析模块之间的导入导出，确定 ESM 模块中哪些导出值未曾其它模块使用，并将其删除，以此实现打包产物的优化。</p><p>需要静态分析，只有 ES6 的模块才支持，Webpack 4 生产环境自动开启</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// package.json中添加</span>
<span class="token punctuation">{</span>
    <span class="token string-property property">&quot;sideEffects&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&quot;*.css&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;babel-polyfill&quot;</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过配置sideEffects，Tree Shaking便开启了，webpack打包时会自动剔除没有引用的js文件。对于业务文件冗余，但又不敢轻易删除的项目特别适合开启Tree Shaking，可以大幅度减少打包体积。</p><h3 id="在-webpack-中启动-tree-shaking" tabindex="-1"><a class="header-anchor" href="#在-webpack-中启动-tree-shaking" aria-hidden="true">#</a> 在 Webpack 中启动 Tree Shaking</h3><p>必须同时满足三个条件：</p><ol><li>使用 ESM 规范编写模块代码</li><li>配置 optimization.usedExports 为 true，启动标记功能</li><li>启动代码优化功能，可以通过如下方式实现：</li></ol><ul><li>配置 mode = production</li><li>配置 optimization.minimize = true</li><li>提供 optimization.minimizer 数组</li></ul><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// webpack.config.js</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">entry</span><span class="token operator">:</span> <span class="token string">&quot;./src/index&quot;</span><span class="token punctuation">,</span>
  <span class="token literal-property property">mode</span><span class="token operator">:</span> <span class="token string">&quot;production&quot;</span><span class="token punctuation">,</span>
  <span class="token literal-property property">devtool</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
  <span class="token literal-property property">optimization</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">usedExports</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="理论基础" tabindex="-1"><a class="header-anchor" href="#理论基础" aria-hidden="true">#</a> 理论基础</h3><p>在 CommonJs、AMD、CMD 等旧版本的 JavaScript 模块化方案中，导入导出行为是高度动态，难以预测的，例如：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">if</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">===</span> <span class="token string">&#39;development&#39;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;./bar&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  exports<span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token string">&#39;foo&#39;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而 ESM 方案则从规范层面规避这一行为，它要求所有的导入导出语句只能出现在模块顶层，且导入导出的模块名必须为字符串常量，这意味着下述代码在 ESM 方案下是非法的：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">if</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">===</span> <span class="token string">&#39;development&#39;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">import</span> bar <span class="token keyword">from</span> <span class="token string">&#39;bar&#39;</span><span class="token punctuation">;</span>
  <span class="token keyword">export</span> <span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token string">&#39;foo&#39;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所以，ESM 下模块之间的依赖关系是高度确定的，与运行状态无关，编译工具只需要对 ESM 模块做静态分析，就可以从代码字面量中推断出哪些模块值未曾被其它模块使用，这是实现 Tree Shaking 技术的必要条件。</p><h3 id="实现原理" tabindex="-1"><a class="header-anchor" href="#实现原理" aria-hidden="true">#</a> 实现原理</h3><p>Webpack 中，Tree-shaking 的实现一是先标记出模块导出值中哪些没有被用过，二是使用 Terser 删掉这些没被用到的导出语句。标记过程大致可划分为三个步骤：</p><ul><li>Make 阶段，收集模块导出变量并记录到模块依赖关系图 ModuleGraph 变量中</li><li>Seal 阶段，遍历 ModuleGraph 标记模块导出变量有没有被使用</li><li>生成产物时，若变量没有被其它模块使用则删除对应的导出语句</li></ul><blockquote><p>标记功能需要配置 <code>optimization.usedExports = true</code> 开启</p></blockquote><p>也就是说，标记的效果就是删除没有被其它模块使用的导出语句</p><p>但实际上标记功能只会影响到模块的导出语句，真正执行“Shaking”操作的是 Terser 插件提供的 DCE 功能。</p><h4 id="收集模块导出" tabindex="-1"><a class="header-anchor" href="#收集模块导出" aria-hidden="true">#</a> 收集模块导出</h4><p>首先，Webpack 需要弄清楚每个模块分别有什么导出值，这一过程发生在 make 阶段，大体流程：</p><ol><li>将模块的所有 ESM 导出语句转换为 Dependency 对象，并记录到 module 对象的 dependencies 集合，转换规则：</li></ol><ul><li>具名导出转换为 HarmonyExportSpecifierDependency 对象</li><li>default 导出转换为 HarmonyExportExpressionDependency 对象</li></ul><ol start="2"><li>所有模块都编译完毕后，触发 compilation.hooks.finishModules 钩子，开始执行 FlagDependencyExportsPlugin 插件回调</li><li>FlagDependencyExportsPlugin 插件从 entry 开始读取 ModuleGraph 中存储的模块信息，遍历所有 module 对象</li><li>遍历 module 对象的 dependencies 数组，找到所有 HarmonyExportXXXDependency 类型的依赖对象，将其转换为 ExportInfo 对象并记录到 ModuleGraph 体系中</li></ol><p>经过 FlagDependencyExportsPlugin 插件处理后，所有 ESM 风格的 export 语句都会记录在 ModuleGraph 体系内，后续操作就可以从 ModuleGraph 中直接读取出模块的导出值。</p><h4 id="标记模块导出" tabindex="-1"><a class="header-anchor" href="#标记模块导出" aria-hidden="true">#</a> 标记模块导出</h4><p>模块导出信息收集完毕后，Webpack 需要标记出各个模块的导出列表中，哪些导出值有被其它模块用到，哪些没有，这一过程发生在 Seal 阶段，主流程：</p><ol><li>触发 compilation.hooks.optimizeDependencies 钩子，开始执行 FlagDependencyUsagePlugin 插件逻辑</li><li>在 FlagDependencyUsagePlugin 插件中，从 entry 开始逐步遍历 ModuleGraph 存储的所有 module 对象</li><li>遍历 module 对象对应的 exportInfo 数组</li><li>为每一个 exportInfo 对象执行 compilation.getDependencyReferencedExports 方法，确定其对应的 dependency 对象有否被其它模块使用</li><li>被任意模块使用到的导出值，调用 exportInfo.setUsedConditionally 方法将其标记为已被使用。</li><li>exportInfo.setUsedConditionally 内部修改 exportInfo._usedInRuntime 属性，记录该导出被如何使用</li></ol><p>上面是极度简化过的版本，中间还存在非常多的分支逻辑与复杂的集合操作，我们抓住重点：标记模块导出这一操作集中在 FlagDependencyUsagePlugin 插件中，执行结果最终会记录在模块导出语句对应的 exportInfo._usedInRuntime 字典中</p><h4 id="生成代码" tabindex="-1"><a class="header-anchor" href="#生成代码" aria-hidden="true">#</a> 生成代码</h4><p>由导出语句对应的 HarmonyExportXXXDependency 类实现，大体的流程：</p><ol><li>打包阶段，调用 HarmonyExportXXXDependency.Template.apply 方法生成代码</li><li>在 apply 方法内，读取 ModuleGraph 中存储的 exportsInfo 信息，判断哪些导出值被使用，哪些未被使用</li><li>对已经被使用及未被使用的导出值，分别创建对应的 HarmonyExportInitFragment 对象，保存到 initFragments 数组</li><li>遍历 initFragments 数组，生成最终结果</li></ol><p>基本上，这一步的逻辑就是用前面收集好的 exportsInfo 对象未模块的导出值分别生成导出语句。</p><h4 id="删除代码" tabindex="-1"><a class="header-anchor" href="#删除代码" aria-hidden="true">#</a> 删除代码</h4><p>经过前面几步操作之后，模块导出列表中未被使用的值都不会定义在 <strong>webpack_exports</strong> 对象中，形成一段不可能被执行的 Dead Code 效果.</p><p>在此之后，将由 Terser、UglifyJS 等 DCE 工具“摇”掉这部分无效代码，构成完整的 Tree Shaking 操作。</p><h4 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h4><ul><li>在 FlagDependencyExportsPlugin 插件中根据模块的 dependencies 列表收集模块导出值，并记录到 ModuleGraph 体系的 exportsInfo 中</li><li>在 FlagDependencyUsagePlugin 插件中收集模块的导出值的使用情况，并记录到 exportInfo._usedInRuntime 集合中</li><li>在 HarmonyExportXXXDependency.Template.apply 方法中根据导出值的使用情况生成不同的导出语句</li><li>使用 DCE 工具删除 Dead Code，实现完整的树摇效果</li></ul><h2 id="优化打包速度" tabindex="-1"><a class="header-anchor" href="#优化打包速度" aria-hidden="true">#</a> 优化打包速度</h2><ul><li>减少文件搜索范围：比如通过别名、设置 loader 的 test，include &amp; exclude</li><li>Webpack4 默认压缩并行</li><li>Happypack 将 Loader 的同步执行转换为并行的</li><li>DLLPlugin 将特定的类库提前打包然后引入</li><li>babel 也可以缓存编译</li></ul><h2 id="优化项目" tabindex="-1"><a class="header-anchor" href="#优化项目" aria-hidden="true">#</a> 优化项目</h2><ul><li>对于 Webpack4，打包项目使用 production 模式，这样会自动开启代码压缩</li><li>使用 ES6 模块来开启 tree shaking，这个技术可以移除没有使用的代码</li><li>优化图片，对于小图可以使用 base64 的方式写入文件中</li><li>按照路由拆分代码，实现按需加载</li><li>给打包出来的文件名添加哈希，实现浏览器缓存文件</li></ul><h1 id="rollup" tabindex="-1"><a class="header-anchor" href="#rollup" aria-hidden="true">#</a> Rollup</h1><p>Rollup 是一个 JavaScript 模块打包器，可以将小块代码编译成大块复杂的代码，例如 library 或应用程序。并且可以对代码模块使用新的标准化格式，比如 CommonJS 和 es module。</p><h2 id="构建流程-1" tabindex="-1"><a class="header-anchor" href="#构建流程-1" aria-hidden="true">#</a> 构建流程</h2><p>Rollup 相对 Webpack 而言，打包出来的包会更加轻量化，更适用于类库打包，因为内置了 Tree Shaking 机制，在分析代码阶段就知晓哪些文件引入并未调用，打包时就会自动擦除未使用的代码。</p><p>工作机制：</p><ol><li>确定入口文件</li><li>使用 <code>Acorn</code> 读取解析文件，获取抽象语法树 AST</li><li>分析代码</li><li>生成代码，输出</li></ol><blockquote><p>Acorn 是一个 JavaScript 语法解析器，它将 JavaScript 字符串解析成语法抽象树 AST</p></blockquote><h2 id="核心概念-1" tabindex="-1"><a class="header-anchor" href="#核心概念-1" aria-hidden="true">#</a> 核心概念</h2><ul><li>input：入口文件路径</li><li>output：输出文件、输出格式（amd/es6/iife/umd/cjs）、sourcemap 启用等</li><li>plugin: 各种插件使用的配置</li><li>external: 提取外部依赖</li><li>global: 配置全局变量</li></ul><h2 id="配置" tabindex="-1"><a class="header-anchor" href="#配置" aria-hidden="true">#</a> 配置</h2><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">import</span> commonjs <span class="token keyword">from</span> <span class="token string">&#39;@rollup/plugin-commonjs&#39;</span>
<span class="token keyword">import</span> resolve <span class="token keyword">from</span> <span class="token string">&#39;@rollup/plugin-node-resolve&#39;</span>
<span class="token comment">// 解析json</span>
<span class="token keyword">import</span> json <span class="token keyword">from</span> <span class="token string">&#39;@rollup/plugin-json&#39;</span>
<span class="token comment">// 压缩代码</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> terser <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;rollup-plugin-terser&#39;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">input</span><span class="token operator">:</span> <span class="token string">&#39;src/main.js&#39;</span><span class="token punctuation">,</span>
  <span class="token literal-property property">output</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
      <span class="token literal-property property">file</span><span class="token operator">:</span> <span class="token string">&#39;dist/esmbundle.js&#39;</span><span class="token punctuation">,</span>
      <span class="token literal-property property">format</span><span class="token operator">:</span> <span class="token string">&#39;esm&#39;</span><span class="token punctuation">,</span>
      <span class="token literal-property property">plugins</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token function">terser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
      <span class="token literal-property property">file</span><span class="token operator">:</span> <span class="token string">&#39;dist/cjsbundle.js&#39;</span><span class="token punctuation">,</span>
      <span class="token literal-property property">format</span><span class="token operator">:</span> <span class="token string">&#39;cjs&#39;</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token comment">// commonjs 需要放到 transform 插件之前，</span>
  <span class="token comment">// 但是又个例外， 是需要放到 babel 之后的</span>
  <span class="token literal-property property">plugins</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">commonjs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token literal-property property">external</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&#39;vue&#39;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="测试" tabindex="-1"><a class="header-anchor" href="#测试" aria-hidden="true">#</a> 测试</h1><h2 id="单元测试" tabindex="-1"><a class="header-anchor" href="#单元测试" aria-hidden="true">#</a> 单元测试</h2><blockquote><p>对最小可测试单元（一般为单个函数、类或组件）进行检查和验证</p></blockquote><p>Mocha、断言库 Chai、Sinon、Jest 等。我们可以先选择 jest 来学习，因为它集成了 Mocha，chai，jsdom，sinon 等功能</p><h2 id="组件测试" tabindex="-1"><a class="header-anchor" href="#组件测试" aria-hidden="true">#</a> 组件测试</h2><blockquote><p>针对某个组件功能进行测试</p></blockquote><p>因为很多组件涉及了 DOM 操作，可以借助组件测试框架来做，比如使用 Cypress</p><h2 id="e2e-测试" tabindex="-1"><a class="header-anchor" href="#e2e-测试" aria-hidden="true">#</a> e2e 测试</h2><blockquote><p>端到端测试，主要是模拟用户对页面进行一系列操作并验证其是否符合预期，使用 Cypress</p></blockquote><h1 id="基础建设" tabindex="-1"><a class="header-anchor" href="#基础建设" aria-hidden="true">#</a> 基础建设</h1><h2 id="脚手架" tabindex="-1"><a class="header-anchor" href="#脚手架" aria-hidden="true">#</a> 脚手架</h2><p>解耦：脚手架与模板分离 脚手架负责构建流程，通过命令行与用户交互，获取项目信息 模板负责统一项目结构、工作流程、依赖项管理 脚手架需要检测模板的版本是否有更新，支持模板的删除与新建</p><h2 id="组件库" tabindex="-1"><a class="header-anchor" href="#组件库" aria-hidden="true">#</a> 组件库</h2><p>选择通用、合适、便捷的构建工具，方便打包代码，并且易于调试； 注重代码质量和开发效率，有类型推断及静态检查能力（提前写好 TS）； api 简单易用，易于上手，文档实时更新； 支持按需加载，支持组件的继承，支持组件的插件化； 易于开发者拓展、版本升级保持向前兼容。</p><h1 id="npm" tabindex="-1"><a class="header-anchor" href="#npm" aria-hidden="true">#</a> NPM</h1><h2 id="npm-run" tabindex="-1"><a class="header-anchor" href="#npm-run" aria-hidden="true">#</a> npm run ***</h2><ol><li>运行 npm run xxx的时候，npm 会先在当前目录的 node_modules/.bin 查找要执行的程序，如果找到则运行；</li><li>没有找到则从全局的 node_modules/.bin 中查找，npm i -g xxx就是安装到到全局目录；</li><li>如果全局目录还是没找到，那么就从 path 环境变量中查找有没有其他同名的可执行程序。</li></ol><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code># unix 系默认的可执行文件，必须输入完整文件名
vue<span class="token operator">-</span>cli<span class="token operator">-</span>service

# windows cmd 中默认的可执行文件，当我们不添加后缀名时，自动根据 pathext 查找文件
vue<span class="token operator">-</span>cli<span class="token operator">-</span>service<span class="token punctuation">.</span>cmd

# Windows PowerShell 中可执行文件，可以跨平台
vue<span class="token operator">-</span>cli<span class="token operator">-</span>service<span class="token punctuation">.</span>ps1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以vue-cli-service serve为例</p><p>从 package-lock.json 中可知，当我们npm i 整个新建的vue项目的时候，npm 将 bin/vue-cli-service.js 作为 bin 声明了。</p><p>所以在 npm install 时，npm 读到该配置后，就将该文件软链接到 ./node_modules/.bin 目录下，而 npm 还会自动把node_modules/.bin加入$PATH，这样就可以直接作为命令运行依赖程序和开发依赖程序，不用全局安装了。</p><p>假如我们在安装包时，使用 npm install -g xxx 来安装，那么会将其中的 bin 文件加入到全局，比如 create-react-app 和 vue-cli ，在全局安装后，就可以直接使用如 vue-cli projectName 这样的命令来创建项目了。</p></div><!--[--><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: xiaodigen@yzgong.com">肖笛根</span><!----><!--]--><!--]--></span></div></footer><nav class="page-nav"><p class="inner"><span class="prev"><a href="/architecture/optimize.html" class="" aria-label="优化"><!--[--><!--]--> 优化 <!--[--><!--]--></a></span><span class="next"><a href="/architecture/micro.html" class="" aria-label="微前端"><!--[--><!--]--> 微前端 <!--[--><!--]--></a></span></p></nav><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/app.97d76f07.mjs" defer></script>
  </body>
</html>
