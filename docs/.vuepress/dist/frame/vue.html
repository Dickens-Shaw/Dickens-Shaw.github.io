<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress [object Promise]">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <title>Vue | Shaw</title><meta name="description" content="这是我的第一个 VuePress 站点">
    <link rel="modulepreload" href="/assets/vue.html.778d5636.js"><link rel="modulepreload" href="/assets/vue.html.5e84b882.js"><link rel="prefetch" href="/assets/index.html.93a9cfaa.js"><link rel="prefetch" href="/assets/browser.html.a54b332a.js"><link rel="prefetch" href="/assets/data.html.4ba0a106.js"><link rel="prefetch" href="/assets/design.html.28cf13ae.js"><link rel="prefetch" href="/assets/network.html.bd0988dd.js"><link rel="prefetch" href="/assets/typescript.html.198f7fc9.js"><link rel="prefetch" href="/assets/async.html.88b18e22.js"><link rel="prefetch" href="/assets/css.html.ed9b5713.js"><link rel="prefetch" href="/assets/es6.html.55944a4a.js"><link rel="prefetch" href="/assets/eventLoop.html.9d82381c.js"><link rel="prefetch" href="/assets/js.html.7b6826f4.js"><link rel="prefetch" href="/assets/formatter.html.f361f7b8.js"><link rel="prefetch" href="/assets/juejin.html.d01502c9.js"><link rel="prefetch" href="/assets/wechat.html.669c1514.js"><link rel="prefetch" href="/assets/common.html.c1193a10.js"><link rel="prefetch" href="/assets/react.html.73d3be5a.js"><link rel="prefetch" href="/assets/cross.html.6ad7ed6e.js"><link rel="prefetch" href="/assets/engineering.html.cd482ee7.js"><link rel="prefetch" href="/assets/lowcode.html.30869335.js"><link rel="prefetch" href="/assets/micro.html.bc38576d.js"><link rel="prefetch" href="/assets/optimize.html.7d2957ee.js"><link rel="prefetch" href="/assets/404.html.265028f6.js"><link rel="prefetch" href="/assets/index.html.46a6b8bc.js"><link rel="prefetch" href="/assets/browser.html.8c33f778.js"><link rel="prefetch" href="/assets/data.html.5e391979.js"><link rel="prefetch" href="/assets/design.html.05fbc41e.js"><link rel="prefetch" href="/assets/network.html.726d20fb.js"><link rel="prefetch" href="/assets/typescript.html.ed035233.js"><link rel="prefetch" href="/assets/async.html.42c6a6ce.js"><link rel="prefetch" href="/assets/css.html.f47d2209.js"><link rel="prefetch" href="/assets/es6.html.600c402e.js"><link rel="prefetch" href="/assets/eventLoop.html.84b2ee43.js"><link rel="prefetch" href="/assets/js.html.b2689a6b.js"><link rel="prefetch" href="/assets/formatter.html.eade2199.js"><link rel="prefetch" href="/assets/juejin.html.5a786eb6.js"><link rel="prefetch" href="/assets/wechat.html.c2018222.js"><link rel="prefetch" href="/assets/common.html.22c60bf3.js"><link rel="prefetch" href="/assets/react.html.5fd9c318.js"><link rel="prefetch" href="/assets/cross.html.56a9eec3.js"><link rel="prefetch" href="/assets/engineering.html.9a633182.js"><link rel="prefetch" href="/assets/lowcode.html.330655e1.js"><link rel="prefetch" href="/assets/micro.html.545c727b.js"><link rel="prefetch" href="/assets/optimize.html.a22168f9.js"><link rel="prefetch" href="/assets/404.html.973816a9.js"><link rel="prefetch" href="/assets/404.2da2d90e.js"><link rel="prefetch" href="/assets/Layout.f17195d2.js">
    <link rel="stylesheet" href="/assets/style.95e11607.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/" class=""><img class="logo" src="/images/logo.jpeg" alt="Shaw"><span class="site-name can-hide">Shaw</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="基础"><span class="title">基础</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="基础"><span class="title">基础</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/basic/css" class="" aria-label="CSS基础"><!--[--><!--]--> CSS基础 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/basic/js" class="" aria-label="JS基础"><!--[--><!--]--> JS基础 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/basic/es6" class="" aria-label="ES6+"><!--[--><!--]--> ES6+ <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/basic/async" class="" aria-label="异步编程"><!--[--><!--]--> 异步编程 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/basic/eventLoop" class="" aria-label="事件循环"><!--[--><!--]--> 事件循环 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="进阶"><span class="title">进阶</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="进阶"><span class="title">进阶</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/advance/browser" class="" aria-label="浏览器"><!--[--><!--]--> 浏览器 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/advance/network" class="" aria-label="网络"><!--[--><!--]--> 网络 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/advance/typescript" class="" aria-label="TS"><!--[--><!--]--> TS <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/advance/design" class="" aria-label="设计模式"><!--[--><!--]--> 设计模式 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/advance/data" class="" aria-label="数据结构&amp;算法"><!--[--><!--]--> 数据结构&amp;算法 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="框架"><span class="title">框架</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="框架"><span class="title">框架</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/frame/common" class="" aria-label="MVVM"><!--[--><!--]--> MVVM <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/frame/react" class="" aria-label="React"><!--[--><!--]--> React <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/frame/vue" class="router-link-active" aria-label="Vue"><!--[--><!--]--> Vue <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="架构"><span class="title">架构</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="架构"><span class="title">架构</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/architecture/optimize" class="" aria-label="项目优化"><!--[--><!--]--> 项目优化 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/architecture/engineering" class="" aria-label="工程化"><!--[--><!--]--> 工程化 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/architecture/micro" class="" aria-label="微前端"><!--[--><!--]--> 微前端 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/architecture/cross" class="" aria-label="大前端"><!--[--><!--]--> 大前端 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/architecture/lowcode" class="" aria-label="低代码"><!--[--><!--]--> 低代码 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="收藏夹"><span class="title">收藏夹</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="收藏夹"><span class="title">收藏夹</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/bookmark/juejin" class="" aria-label="掘金"><!--[--><!--]--> 掘金 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/bookmark/wechat" class="" aria-label="微信"><!--[--><!--]--> 微信 <!--[--><!--]--></a></li><!--]--></ul></div></div><!--]--></nav><!--[--><!--]--><button class="toggle-color-mode-button" title="toggle color mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><form class="search-box" role="search"><input type="search" placeholder="搜索" autocomplete="off" spellcheck="false" value><!----></form></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="基础"><span class="title">基础</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="基础"><span class="title">基础</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/basic/css" class="" aria-label="CSS基础"><!--[--><!--]--> CSS基础 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/basic/js" class="" aria-label="JS基础"><!--[--><!--]--> JS基础 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/basic/es6" class="" aria-label="ES6+"><!--[--><!--]--> ES6+ <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/basic/async" class="" aria-label="异步编程"><!--[--><!--]--> 异步编程 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/basic/eventLoop" class="" aria-label="事件循环"><!--[--><!--]--> 事件循环 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="进阶"><span class="title">进阶</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="进阶"><span class="title">进阶</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/advance/browser" class="" aria-label="浏览器"><!--[--><!--]--> 浏览器 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/advance/network" class="" aria-label="网络"><!--[--><!--]--> 网络 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/advance/typescript" class="" aria-label="TS"><!--[--><!--]--> TS <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/advance/design" class="" aria-label="设计模式"><!--[--><!--]--> 设计模式 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/advance/data" class="" aria-label="数据结构&amp;算法"><!--[--><!--]--> 数据结构&amp;算法 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="框架"><span class="title">框架</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="框架"><span class="title">框架</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/frame/common" class="" aria-label="MVVM"><!--[--><!--]--> MVVM <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/frame/react" class="" aria-label="React"><!--[--><!--]--> React <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/frame/vue" class="router-link-active" aria-label="Vue"><!--[--><!--]--> Vue <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="架构"><span class="title">架构</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="架构"><span class="title">架构</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/architecture/optimize" class="" aria-label="项目优化"><!--[--><!--]--> 项目优化 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/architecture/engineering" class="" aria-label="工程化"><!--[--><!--]--> 工程化 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/architecture/micro" class="" aria-label="微前端"><!--[--><!--]--> 微前端 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/architecture/cross" class="" aria-label="大前端"><!--[--><!--]--> 大前端 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/architecture/lowcode" class="" aria-label="低代码"><!--[--><!--]--> 低代码 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="收藏夹"><span class="title">收藏夹</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="收藏夹"><span class="title">收藏夹</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/bookmark/juejin" class="" aria-label="掘金"><!--[--><!--]--> 掘金 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/bookmark/wechat" class="" aria-label="微信"><!--[--><!--]--> 微信 <!--[--><!--]--></a></li><!--]--></ul></div></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading active">前端框架 <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a href="/frame/common.html" class="sidebar-item" aria-label="框架"><!--[--><!--]--> 框架 <!--[--><!--]--></a><!----></li><li><a href="/frame/react.html" class="sidebar-item" aria-label="React"><!--[--><!--]--> React <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/frame/vue.html" class="router-link-active router-link-exact-active router-link-active sidebar-item active" aria-label="Vue"><!--[--><!--]--> Vue <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/frame/vue.html#基本原理" class="router-link-active router-link-exact-active sidebar-item" aria-label="基本原理"><!--[--><!--]--> 基本原理 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/frame/vue.html#响应式原理" class="router-link-active router-link-exact-active sidebar-item" aria-label="响应式原理"><!--[--><!--]--> 响应式原理 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/frame/vue.html#单项数据流" class="router-link-active router-link-exact-active sidebar-item" aria-label="单项数据流"><!--[--><!--]--> 单项数据流 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/frame/vue.html#生命周期" class="router-link-active router-link-exact-active sidebar-item" aria-label="生命周期"><!--[--><!--]--> 生命周期 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/frame/vue.html#组件通信" class="router-link-active router-link-exact-active sidebar-item" aria-label="组件通信"><!--[--><!--]--> 组件通信 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/frame/vue.html#渲染过程" class="router-link-active router-link-exact-active sidebar-item" aria-label="渲染过程"><!--[--><!--]--> 渲染过程 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/frame/vue.html#编译过程" class="router-link-active router-link-exact-active sidebar-item" aria-label="编译过程"><!--[--><!--]--> 编译过程 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/frame/vue.html#性能优化" class="router-link-active router-link-exact-active sidebar-item" aria-label="性能优化"><!--[--><!--]--> 性能优化 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/frame/vue.html#diff" class="router-link-active router-link-exact-active sidebar-item" aria-label="Diff"><!--[--><!--]--> Diff <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/frame/vue.html#mixin-和-mixins-区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="mixin 和 mixins 区别"><!--[--><!--]--> mixin 和 mixins 区别 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/frame/vue.html#v-show-与-v-if-区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="v-show 与 v-if 区别"><!--[--><!--]--> v-show 与 v-if 区别 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/frame/vue.html#computed" class="router-link-active router-link-exact-active sidebar-item" aria-label="computed"><!--[--><!--]--> computed <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/frame/vue.html#watch" class="router-link-active router-link-exact-active sidebar-item" aria-label="watch"><!--[--><!--]--> watch <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/frame/vue.html#组件-data-为什么是函数" class="router-link-active router-link-exact-active sidebar-item" aria-label="组件 data 为什么是函数"><!--[--><!--]--> 组件 data 为什么是函数 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/frame/vue.html#v-for-的-key" class="router-link-active router-link-exact-active sidebar-item" aria-label="v-for 的 key"><!--[--><!--]--> v-for 的 key <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/frame/vue.html#v-model" class="router-link-active router-link-exact-active sidebar-item" aria-label="v-model"><!--[--><!--]--> v-model <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/frame/vue.html#vue-set-原理" class="router-link-active router-link-exact-active sidebar-item" aria-label="Vue.set 原理"><!--[--><!--]--> Vue.set 原理 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/frame/vue.html#nexttick" class="router-link-active router-link-exact-active sidebar-item" aria-label="nextTick"><!--[--><!--]--> nextTick <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/frame/vue.html#keep-alive" class="router-link-active router-link-exact-active sidebar-item" aria-label="keep-alive"><!--[--><!--]--> keep-alive <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/frame/vue.html#proxy-对比" class="router-link-active router-link-exact-active sidebar-item" aria-label="Proxy 对比"><!--[--><!--]--> Proxy 对比 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/frame/vue.html#vue-composition-api" class="router-link-active router-link-exact-active sidebar-item" aria-label="Vue-Composition-Api:"><!--[--><!--]--> Vue-Composition-Api: <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/frame/vue.html#vuex" class="router-link-active router-link-exact-active sidebar-item" aria-label="Vuex"><!--[--><!--]--> Vuex <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/frame/vue.html#action-和-mutation-的区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="Action 和 mutation 的区别"><!--[--><!--]--> Action 和 mutation 的区别 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><h1 id="vue" tabindex="-1"><a class="header-anchor" href="#vue" aria-hidden="true">#</a> Vue</h1><h2 id="基本原理" tabindex="-1"><a class="header-anchor" href="#基本原理" aria-hidden="true">#</a> 基本原理</h2><p>当一个 Vue 实例创建时，vue 会遍历 data 选项的属性，用 Object.defineProperty（vue3.0 使用 proxy ）将它们转为 getter/setter 并且在内部追踪相关依赖，在属性被访问和修改时通知变化。 每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新。</p><h2 id="响应式原理" tabindex="-1"><a class="header-anchor" href="#响应式原理" aria-hidden="true">#</a> 响应式原理</h2><ol><li>任何一个 Vue Component 都有一个与之对应的 Watcher 实例。</li><li>Vue 的 data 上的属性会被添加 getter 和 setter 属性。</li><li>当 Vue Component render 函数被执行的时候, data 上会被 触碰(touch), 即被读, getter 方法会被调用, 此时 Vue 会去记录此 Vue component 所依赖的所有 data。(这一过程被称为依赖收集)</li><li>data 被改动时（主要是用户操作）, 即被写, setter 方法会被调用, 此时 Vue 会去通知所有依赖于此 data 的组件去调用他们的 render 函数进行更新。</li></ol><p>通过数据劫持结合发布-订阅模式实现：</p><ul><li>在初始化 data props 时，递归对象，给每一个属性双向绑定，对于数组而言，会拿到原型重写函数，实现手动派发更新。因为函数不能监听到数据的变动，和 proxy 比较一下。</li><li>除了以上数组函数，通过索引改变数组数据或者给对象添加新属性也不能触发，需要使用自带的 set 函数，这个函数内部也是手动派发更新</li><li>在组件挂载时，会实例化渲染观察者，传入组件更新的回调。在实例化过程中，会对模板中的值对象进行求值，触发依赖收集。在触发依赖之前，会保存当前的渲染观察者，用于组件含有子组件的时候，恢复父组件的观察者。触发依赖收集后，会清理掉不需要的依赖，性能优化，防止不需要的地方去重复渲染。</li><li>改变值会触发依赖更新，会将收集到的所有依赖全部拿出来，放入 nextTick 中统一执行。执行过程中，会先对观察者进行排序，渲染的最后执行。先执行 beforeupdate 钩子函数，然后执行观察者的回调。在执行回调的过程中，可能 watch 会再次 push 进来，因为存在在回调中再次赋值，判断无限循环。</li></ul><ol><li>实现一个监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。</li></ol><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">definereactive</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> dep <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dep</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">//添加订阅者watcher到主题对象Dep</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// js的浏览器单线程特性，保证这个全局变量在同一时间内，只会有同一个监听器使用</span>
        dep<span class="token punctuation">.</span><span class="token function">addSub</span><span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> val
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function-variable function">set</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">newVal</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>newVal <span class="token operator">===</span> val<span class="token punctuation">)</span> <span class="token keyword">return</span>
      val <span class="token operator">=</span> newVal
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>
      <span class="token comment">// 作为发布者发出通知</span>
      dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//通知后dep会循环调用各自的update方法更新视图</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">observe</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> vm</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">definereactive</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> key<span class="token punctuation">,</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li><p>实现一个解析器 Compile：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。</p></li><li><p>实现一个订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。</p></li></ol><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Watcher</span><span class="token punctuation">(</span><span class="token parameter">vm<span class="token punctuation">,</span> node<span class="token punctuation">,</span> name<span class="token punctuation">,</span> type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">this</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
  <span class="token keyword">this</span><span class="token punctuation">.</span>node <span class="token operator">=</span> node
  <span class="token keyword">this</span><span class="token punctuation">.</span>vm <span class="token operator">=</span> vm
  <span class="token keyword">this</span><span class="token punctuation">.</span>type <span class="token operator">=</span> type
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">null</span>
<span class="token punctuation">}</span>
<span class="token class-name">Watcher</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">update</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>node<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>type<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token comment">// 订阅者执行相应操作</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token comment">// 获取data的属性值</span>
  <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>vm<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">]</span> <span class="token comment">//触发相应属性的get</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>4.实现一个订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Dep</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>subs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
<span class="token class-name">Dep</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">addSub</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">sub</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>sub<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function-variable function">notify</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">sub</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      sub<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li><img src="/images/vue.png" alt="blockchain"></li></ol><h2 id="单项数据流" tabindex="-1"><a class="header-anchor" href="#单项数据流" aria-hidden="true">#</a> 单项数据流</h2><p>所有 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外修改父组件的状态。 额外的，每次父组件发生变更时，子组件中所有 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器控制台中发出警告。子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。</p><h2 id="生命周期" tabindex="-1"><a class="header-anchor" href="#生命周期" aria-hidden="true">#</a> 生命周期</h2><ol><li><p>在 beforeCreate 钩子函数调用的时候，是获取不到 props 或者 data 中的数据的，因为这些数据的初始化都在 initState 中。</p></li><li><p>然后会执行 created 钩子函数，在这一步的时候已经可以访问到之前不能访问到的数据，但是这时候组件还没被挂载，所以是看不到的。</p></li><li><p>接下来会先执行 beforeMount 钩子函数，开始创建 VDOM，最后执行 mounted 钩子，并将 VDOM 渲染为真实 DOM 并且渲染数据。组件中如果有子组件的话，会递归挂载子组件，只有当所有子组件全部挂载完毕，才会执行根组件的挂载钩子。</p></li><li><p>接下来是数据更新时会调用的钩子函数 beforeUpdate 和 updated，这两个钩子函数没什么好说的，就是分别在数据更新前和更新后会调用。</p></li><li><p>另外还有 keep-alive 独有的生命周期，分别为 activated 和 deactivated 。用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 actived 钩子函数。</p></li><li><p>最后就是销毁组件的钩子函数 beforeDestroy 和 destroyed。前者适合移除事件、定时器等等，否则可能会引起内存泄露的问题。然后进行一系列的销毁操作，如果有子组件的话，也会递归销毁子组件，所有子组件都销毁完毕后才会执行根组件的 destroyed 钩子函数。</p></li></ol><h2 id="组件通信" tabindex="-1"><a class="header-anchor" href="#组件通信" aria-hidden="true">#</a> 组件通信</h2><ul><li>父子组件 <ol><li>父组件通过 props 传递数据给子组件，子组件通过 emit 发送事件传递数据给父组件（单项数据流）</li><li>ref、$parent / $children 对象来访问组件实例中的方法和数据</li><li>.sync 属性是个语法糖</li></ol></li></ul><div class="language-vue ext-vue line-numbers-mode"><pre class="language-vue"><code><span class="token comment">&lt;!--父组件中--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">:value.sync</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>value<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token comment">&lt;!--以上写法等同于--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">:value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>value<span class="token punctuation">&quot;</span></span> <span class="token attr-name"><span class="token namespace">@update:</span>value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>(v) =&gt; (value = v)<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token comment">&lt;!--子组件中--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">&#39;update:value&#39;</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>兄弟组件 查找父组件中的子组件实现，也就是 this.$parent.$children，在 $children 中可以通过组件 name 查询到需要的组件实例，然后进行通信</p></li><li><p>跨层级组件</p><ol><li>provide / inject：祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。</li><li>$attrs：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 v-bind=&quot;$attrs&quot; 传入内部组件。通常配合 inheritAttrs 选项一起使用。</li><li>$listeners：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=&quot;$listeners&quot; 传入内部组件</li></ol></li><li><p>任意组件 Vuex 或者 Event Bus</p></li></ul><h2 id="渲染过程" tabindex="-1"><a class="header-anchor" href="#渲染过程" aria-hidden="true">#</a> 渲染过程</h2><ul><li><p>初次渲染：</p><ol><li>解析模板为 render 函数</li><li>触发响应式，监听 data 属性的 getter setter</li><li>执行 render 函数，会生成 vnode 并且渲染出页面</li></ol></li><li><p>更新渲染：</p><ol><li>修改 data，触发 setter</li><li>重新执行 render 函数，生成新的 vnode</li><li>diff 算法对比新旧 vnode ，更新页面</li></ol></li><li><p>异步渲染</p></li></ul><p>Vue 是组件级更新，如果不采用异步更新，那么每次更新数据都会对当前组件进行重新渲染，所以为了性能， Vue 会在本轮数据更新后，在异步更新视图。核心思想 nextTick 。</p><p>dep.notify（） 通知 watcher 进行更新， subs[i].update 依次调用 watcher 的 update ， queueWatcher 将 watcher 去重放入队列， nextTick（ flushSchedulerQueue ）在下一 tick 中刷新 watcher 队列（异步）。</p><h2 id="编译过程" tabindex="-1"><a class="header-anchor" href="#编译过程" aria-hidden="true">#</a> 编译过程</h2><ol><li>将模板解析为 AST： 通过各种各样的正则表达式去匹配模板中的内容，然后将内容提取出来做各种逻辑操作生成一个最基本的 AST 对象</li><li>优化 AST： 对节点进行了静态内容提取，也就是将永远不会变动的节点提取了出来，实现复用 Virtual DOM，跳过对比算法的功能</li><li>将 AST 转换为 render 函数： 遍历整个 AST，根据不同的条件生成不同的代码</li></ol><h2 id="性能优化" tabindex="-1"><a class="header-anchor" href="#性能优化" aria-hidden="true">#</a> 性能优化</h2><ul><li>v-if 和 v-show 区分使用场景</li><li>computed 和 watch 区分使用场景</li><li>v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</li><li>长列表性能优化</li><li>事件的销毁</li><li>图片资源懒加载</li><li>路由懒加载</li><li>第三方插件的按需引入</li><li>优化无限列表性能</li><li>服务端渲染 SSR or 预渲染</li></ul><h2 id="diff" tabindex="-1"><a class="header-anchor" href="#diff" aria-hidden="true">#</a> Diff</h2><p>diff 学习 snabbdom.js 双端标记学习 cito.js vue 的数据检测原理是可以知道哪里用到了某个数据，数据变化的时候可以直接通知到对应的 watcher 进行修改。那为什么还需要用 diff 算法呢？因为粒度太细，会有很多 watcher 同时观察某个状态，会有一些内存开销以及一些依赖追踪的开销，所以 Vue.js 2.0 采用了一个中等粒度的解决方案，状态侦测不再细化到某个具体节点，而是组件，组件内部通过虚拟 DOM 来渲染视图，这可以大大缩减依赖数量和 watcher 数量</p><p>在 Vue.js 2.0 版本中组件更新渲染的时候，会使用新创建的虚拟节点和将上一次渲染时缓存的虚拟节点进行对比，然后根据对比结果只更新需要更新的真实 DOM 节点，从而避免不必要的 DOM 操作，节省一定的性能。 在采取 diff 算法比较新旧节点的时候，比较只会在同层级进行, 不会跨层级比较。</p><p>diff 算法源码执行函数依次是：</p><ul><li><p>patch (oldVnode, vnode) ：</p><ul><li>调用 sameVnode 方法更具 tag、key 判断是否为相同元素：</li><li>相同则走 patchVnode()</li><li>不同则创建新的删除旧的</li></ul></li><li><p>patchVnode (oldVnode, vnode)</p><ul><li>如果新旧节点都有 children 则调用 updateChildren</li><li>否则通过对比新旧节点有无 text 和 children 来做相应的增删或更新</li></ul></li><li><p>updateChildren (parentElm, oldCh, newCh)</p><p>通过<code>双端标记法</code> 对比新老 children 的 start 和 end 是否相等，头头、尾尾、头尾、尾头</p><p>如果四种都未命中则拿新 children 的开始的 key 去老 children 里找：</p><ul><li>没有的话直接添加</li><li>有的话对比 tag(sel)是否相等： <ul><li>不等则直接添加</li><li>相等的话，调用 patchVnode 后。将找到的 old 节点值为 undefine，然后添加新的节点</li></ul></li></ul></li></ul><h2 id="mixin-和-mixins-区别" tabindex="-1"><a class="header-anchor" href="#mixin-和-mixins-区别" aria-hidden="true">#</a> mixin 和 mixins 区别</h2><p>mixin 用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的，可以全局混入装好的 ajax 或者一些工具函数</p><p>mixins 应该是我们最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 mixins 混入代码，比如上拉下拉加载数据这种逻辑等等。 mixins 混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并</p><h2 id="v-show-与-v-if-区别" tabindex="-1"><a class="header-anchor" href="#v-show-与-v-if-区别" aria-hidden="true">#</a> v-show 与 v-if 区别</h2><p>v-show 只是在 display: none 和 display: block 之间切换。无论初始条件是什么都会被渲染出来，后面只需要切换 CSS，DOM 还是一直保留着的。所以总的来说 v-show 在初始渲染时有更高的开销，但是切换开销很小，更适合于频繁切换的场景。</p><p>v-if 的话就得说到 Vue 底层的编译了。当属性初始为 false 时，组件就不会被渲染，直到条件为 true，并且切换条件时会触发销毁/挂载组件，所以总的来说在切换时开销更高，更适合不经常切换的场景。 并且基于 v-if 的这种惰性渲染机制，可以在必要的时候才去渲染组件，减少整个页面的初始渲染开销。</p><h2 id="computed" tabindex="-1"><a class="header-anchor" href="#computed" aria-hidden="true">#</a> computed</h2><p>计算属性，依赖其他属性计算值。并且 computed 的值有缓存，只有当计算值变化才变化触发渲染</p><p>依赖两个 watcher，computer watcher 和渲染 watcher。判断计算出的值变化后渲染 watcher 派发更新触发渲染</p><p>适用于渲染页面，购物车结算</p><h2 id="watch" tabindex="-1"><a class="header-anchor" href="#watch" aria-hidden="true">#</a> watch</h2><p>更多的是观察的作用,无缓存性，监听到值得变化就会执行回调</p><p>配置项有：handler deep immediate</p><p>适合做一些复杂业务逻辑，搜索数据</p><h2 id="组件-data-为什么是函数" tabindex="-1"><a class="header-anchor" href="#组件-data-为什么是函数" aria-hidden="true">#</a> 组件 data 为什么是函数</h2><p>因为组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响</p><p>如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响</p><p>而 new Vue 的实例，是根组件不会被复用的，因此不存在引用对象的问题。</p><h2 id="v-for-的-key" tabindex="-1"><a class="header-anchor" href="#v-for-的-key" aria-hidden="true">#</a> v-for 的 key</h2><p>在虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNode。</p><p>如果不使用 key，Vue 会使用一种最大限度减少新增或删除元素并且尽可能地尝试修复/再利用相同类型元素的算法。（就地复用 tag 相同的真实 DOM 元素）。</p><p>使用 key, 则直接复用 key 值相同的元素。</p><p>带 key 的组件能够触发过渡效果，以及触发组件的声明周期</p><h2 id="v-model" tabindex="-1"><a class="header-anchor" href="#v-model" aria-hidden="true">#</a> v-model</h2><p>v-model 在模板编译的时候转换代码</p><p>v-model 本质是 :value 和 @input，但是略微有点区别。在输入控件下，有两个事件监听，输入中文时只有当输出中文才触发数据赋值</p><p>v-model 和:bind 同时使用，前者优先级更高，如果 :value 会出现冲突</p><p>v-model 因为语法糖的原因，还可以用于父子通信</p><h2 id="vue-set-原理" tabindex="-1"><a class="header-anchor" href="#vue-set-原理" aria-hidden="true">#</a> Vue.set 原理</h2><ol><li><p>如果目标是数组，直接使用数组的 splice 方法触发相应式；</p></li><li><p>如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 defineReactive 方法进行响应式处理（ defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法）</p></li></ol><h2 id="nexttick" tabindex="-1"><a class="header-anchor" href="#nexttick" aria-hidden="true">#</a> nextTick</h2><p>可以让我们在下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的 DOM</p><p>在 Vue 2.4 之前都是使用的 microtasks，但是 microtasks 的优先级过高，在某些情况下可能会出现比事件冒泡更快的情况，但如果都使用 macrotasks 又可能会出现渲染的性能问题。所以在新版本中，会默认使用 microtasks，但在特殊情况下会使用 macrotasks，比如 v-on。</p><p>对于实现 macrotasks ，会先判断是否能使用 setImmediate ，不能的话降级为 MessageChannel ，以上都不行的话就使用 setTimeout nextTick 同时也支持 Promise 的使用，会判断是否实现了 Promise，可以的话给 _resolve 赋值，这样回调函数就能以 promise 的方式调用</p><h2 id="keep-alive" tabindex="-1"><a class="header-anchor" href="#keep-alive" aria-hidden="true">#</a> keep-alive</h2><p>keep-alive 是 Vue 内置组件，主要用于保留组件状态或避免重新渲染。</p><p>如果你需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 keep-alive 组件包裹需要保存的组件。</p><p>对于 keep-alive 组件来说，它拥有两个独有的生命周期钩子函数，分别为 activated 和 deactivated 。用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 actived 钩子函数</p><p>Props: include：字符串或正则表达式。只有名称匹配的组件会被缓存。 exclude：字符串或正则表达式。任何名称匹配的组件都不会被缓存。</p><h2 id="proxy-对比" tabindex="-1"><a class="header-anchor" href="#proxy-对比" aria-hidden="true">#</a> Proxy 对比</h2><p>Proxy 的优势如下:</p><ul><li>Proxy 可以直接监听对象而非属性；</li><li>Proxy 可以直接监听数组的变化；</li><li>Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的；</li><li>Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；</li><li>Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；</li></ul><p>Object.defineProperty 的优势如下:</p><ul><li>兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平</li></ul><h2 id="vue-composition-api" tabindex="-1"><a class="header-anchor" href="#vue-composition-api" aria-hidden="true">#</a> Vue-Composition-Api:</h2><ul><li><p>原理： 在 Vue 中，之所以 setup 函数只执行一次，后续对于数据的更新也可以驱动视图更新，归根结底在于它的「响应式机制」</p></li><li><p>对比：</p><ol><li>与 React Hooks 相同级别的逻辑组合功能，但有一些重要的区别。 与 React Hook 不同，setup 函数仅被调用一次，这在性能上比较占优。</li><li>对调用顺序没什么要求，每次渲染中不会反复调用 Hook 函数，产生的的 GC 压力较小。</li><li>不必考虑几乎总是需要 useCallback 的问题，以防止传递函数 prop 给子组件的引用变化，导致无必要的重新渲染。</li><li>React Hook 有臭名昭著的闭包陷阱问题，如果用户忘记传递正确的依赖项数组，useEffect 和 useMemo 可能会捕获过时的变量，这不受此问题的影响。 Vue 的自动依赖关系跟踪确保观察者和计算值始终正确无误。</li><li>不得不提一句，React Hook 里的「依赖」是需要你去手动声明的，而且官方提供了一个 eslint 插件，这个插件虽然大部分时候挺有用的，但是有时候也特别烦人，需要你手动加一行丑陋的注释去关闭它。</li></ol></li></ul><h2 id="vuex" tabindex="-1"><a class="header-anchor" href="#vuex" aria-hidden="true">#</a> Vuex</h2><p>Vuex 把组件的共享状态抽出来，以一个全局单例模式管理。</p><p>主要包括：</p><ul><li>State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。</li><li>Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。</li><li>Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。</li><li>Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。</li><li>Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。</li></ul><p>Vuex 应用的核心就是 store (仓库)。 store 基本上就是一个容器，它包含着你的应用中的大部分 状态 (state). Vuex 和单纯的全局对象有以下两点不同：</p><ol><li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应的得到高效更新。</li><li>你不能直接修改 store 中的状态。改变 store 中的状态的唯一途径就是显示地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态地变化。</li></ol><p>Vuex 实现原理是将 state 的数据通过 new Vue() 后，将数据转为响应式的。同时，将 getter 里面定义的数据通过 new Vue 的 computed 实现了计算属性的特点，只有当它的依赖值发生了改变才会被重新计算。</p><h2 id="action-和-mutation-的区别" tabindex="-1"><a class="header-anchor" href="#action-和-mutation-的区别" aria-hidden="true">#</a> Action 和 mutation 的区别</h2><p>action 中处理异步操作，mutation 最好不要。（ mutation 处理异步操作页面数据会修改，但是 devtools 里面的值还是原来的并没有修改。出现了数据不一致，无法追踪数据变化。） mutation 做原子操作 action 可以整合多个 mutation</p></div><!--[--><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: xiaodigen@yzgong.com">肖笛根</span><!----><!--]--><!--]--></span></div></footer><nav class="page-nav"><p class="inner"><span class="prev"><a href="/frame/react.html" class="" aria-label="React"><!--[--><!--]--> React <!--[--><!--]--></a></span><!----></p></nav><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/app.97d76f07.mjs" defer></script>
  </body>
</html>
