<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress [object Promise]">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <title>网络 | Shaw</title><meta name="description" content="这是我的第一个 VuePress 站点">
    <link rel="modulepreload" href="/assets/network.html.bb107186.js"><link rel="modulepreload" href="/assets/network.html.bd0988dd.js"><link rel="prefetch" href="/assets/index.html.93a9cfaa.js"><link rel="prefetch" href="/assets/browser.html.a54b332a.js"><link rel="prefetch" href="/assets/data.html.4ba0a106.js"><link rel="prefetch" href="/assets/design.html.28cf13ae.js"><link rel="prefetch" href="/assets/typescript.html.198f7fc9.js"><link rel="prefetch" href="/assets/formatter.html.f361f7b8.js"><link rel="prefetch" href="/assets/juejin.html.d01502c9.js"><link rel="prefetch" href="/assets/wechat.html.669c1514.js"><link rel="prefetch" href="/assets/async.html.88b18e22.js"><link rel="prefetch" href="/assets/css.html.ed9b5713.js"><link rel="prefetch" href="/assets/es6.html.55944a4a.js"><link rel="prefetch" href="/assets/eventLoop.html.9d82381c.js"><link rel="prefetch" href="/assets/js.html.7b6826f4.js"><link rel="prefetch" href="/assets/common.html.c1193a10.js"><link rel="prefetch" href="/assets/react.html.73d3be5a.js"><link rel="prefetch" href="/assets/vue.html.5e84b882.js"><link rel="prefetch" href="/assets/cross.html.6ad7ed6e.js"><link rel="prefetch" href="/assets/engineering.html.cd482ee7.js"><link rel="prefetch" href="/assets/lowcode.html.30869335.js"><link rel="prefetch" href="/assets/micro.html.bc38576d.js"><link rel="prefetch" href="/assets/optimize.html.7d2957ee.js"><link rel="prefetch" href="/assets/404.html.265028f6.js"><link rel="prefetch" href="/assets/index.html.37ca3281.js"><link rel="prefetch" href="/assets/browser.html.d619d95b.js"><link rel="prefetch" href="/assets/data.html.e3145375.js"><link rel="prefetch" href="/assets/design.html.deaff9e9.js"><link rel="prefetch" href="/assets/typescript.html.06c6687d.js"><link rel="prefetch" href="/assets/formatter.html.2a95d502.js"><link rel="prefetch" href="/assets/juejin.html.0d0ed2f4.js"><link rel="prefetch" href="/assets/wechat.html.b920b383.js"><link rel="prefetch" href="/assets/async.html.68698063.js"><link rel="prefetch" href="/assets/css.html.db339395.js"><link rel="prefetch" href="/assets/es6.html.abc48f38.js"><link rel="prefetch" href="/assets/eventLoop.html.f6e3d83a.js"><link rel="prefetch" href="/assets/js.html.2aa6d63a.js"><link rel="prefetch" href="/assets/common.html.028c051d.js"><link rel="prefetch" href="/assets/react.html.93c57cba.js"><link rel="prefetch" href="/assets/vue.html.a44f81e1.js"><link rel="prefetch" href="/assets/cross.html.fd8bc7fe.js"><link rel="prefetch" href="/assets/engineering.html.1d3bb71e.js"><link rel="prefetch" href="/assets/lowcode.html.c65d36cf.js"><link rel="prefetch" href="/assets/micro.html.2d32ba01.js"><link rel="prefetch" href="/assets/optimize.html.6a242268.js"><link rel="prefetch" href="/assets/404.html.48129d17.js"><link rel="prefetch" href="/assets/404.b2cb7595.js"><link rel="prefetch" href="/assets/Layout.9e7398af.js">
    <link rel="stylesheet" href="/assets/style.95e11607.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/" class=""><img class="logo" src="/images/logo.jpeg" alt="Shaw"><span class="site-name can-hide">Shaw</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="基础"><span class="title">基础</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="基础"><span class="title">基础</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/basic/css" class="" aria-label="CSS基础"><!--[--><!--]--> CSS基础 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/basic/js" class="" aria-label="JS基础"><!--[--><!--]--> JS基础 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/basic/es6" class="" aria-label="ES6+"><!--[--><!--]--> ES6+ <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/basic/async" class="" aria-label="异步编程"><!--[--><!--]--> 异步编程 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/basic/eventLoop" class="" aria-label="事件循环"><!--[--><!--]--> 事件循环 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="进阶"><span class="title">进阶</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="进阶"><span class="title">进阶</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/advance/browser" class="" aria-label="浏览器"><!--[--><!--]--> 浏览器 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/advance/network" class="router-link-active" aria-label="网络"><!--[--><!--]--> 网络 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/advance/typescript" class="" aria-label="TS"><!--[--><!--]--> TS <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/advance/design" class="" aria-label="设计模式"><!--[--><!--]--> 设计模式 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/advance/data" class="" aria-label="数据结构&amp;算法"><!--[--><!--]--> 数据结构&amp;算法 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="框架"><span class="title">框架</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="框架"><span class="title">框架</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/frame/common" class="" aria-label="MVVM"><!--[--><!--]--> MVVM <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/frame/react" class="" aria-label="React"><!--[--><!--]--> React <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/frame/vue" class="" aria-label="Vue"><!--[--><!--]--> Vue <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="架构"><span class="title">架构</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="架构"><span class="title">架构</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/architecture/optimize" class="" aria-label="项目优化"><!--[--><!--]--> 项目优化 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/architecture/engineering" class="" aria-label="工程化"><!--[--><!--]--> 工程化 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/architecture/micro" class="" aria-label="微前端"><!--[--><!--]--> 微前端 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/architecture/cross" class="" aria-label="大前端"><!--[--><!--]--> 大前端 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/architecture/lowcode" class="" aria-label="低代码"><!--[--><!--]--> 低代码 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="收藏夹"><span class="title">收藏夹</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="收藏夹"><span class="title">收藏夹</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/bookmark/juejin" class="" aria-label="掘金"><!--[--><!--]--> 掘金 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/bookmark/wechat" class="" aria-label="微信"><!--[--><!--]--> 微信 <!--[--><!--]--></a></li><!--]--></ul></div></div><!--]--></nav><!--[--><!--]--><button class="toggle-color-mode-button" title="toggle color mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><form class="search-box" role="search"><input type="search" placeholder="搜索" autocomplete="off" spellcheck="false" value><!----></form></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="基础"><span class="title">基础</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="基础"><span class="title">基础</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/basic/css" class="" aria-label="CSS基础"><!--[--><!--]--> CSS基础 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/basic/js" class="" aria-label="JS基础"><!--[--><!--]--> JS基础 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/basic/es6" class="" aria-label="ES6+"><!--[--><!--]--> ES6+ <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/basic/async" class="" aria-label="异步编程"><!--[--><!--]--> 异步编程 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/basic/eventLoop" class="" aria-label="事件循环"><!--[--><!--]--> 事件循环 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="进阶"><span class="title">进阶</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="进阶"><span class="title">进阶</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/advance/browser" class="" aria-label="浏览器"><!--[--><!--]--> 浏览器 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/advance/network" class="router-link-active" aria-label="网络"><!--[--><!--]--> 网络 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/advance/typescript" class="" aria-label="TS"><!--[--><!--]--> TS <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/advance/design" class="" aria-label="设计模式"><!--[--><!--]--> 设计模式 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/advance/data" class="" aria-label="数据结构&amp;算法"><!--[--><!--]--> 数据结构&amp;算法 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="框架"><span class="title">框架</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="框架"><span class="title">框架</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/frame/common" class="" aria-label="MVVM"><!--[--><!--]--> MVVM <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/frame/react" class="" aria-label="React"><!--[--><!--]--> React <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/frame/vue" class="" aria-label="Vue"><!--[--><!--]--> Vue <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="架构"><span class="title">架构</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="架构"><span class="title">架构</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/architecture/optimize" class="" aria-label="项目优化"><!--[--><!--]--> 项目优化 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/architecture/engineering" class="" aria-label="工程化"><!--[--><!--]--> 工程化 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/architecture/micro" class="" aria-label="微前端"><!--[--><!--]--> 微前端 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/architecture/cross" class="" aria-label="大前端"><!--[--><!--]--> 大前端 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/architecture/lowcode" class="" aria-label="低代码"><!--[--><!--]--> 低代码 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="收藏夹"><span class="title">收藏夹</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="收藏夹"><span class="title">收藏夹</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/bookmark/juejin" class="" aria-label="掘金"><!--[--><!--]--> 掘金 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/bookmark/wechat" class="" aria-label="微信"><!--[--><!--]--> 微信 <!--[--><!--]--></a></li><!--]--></ul></div></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading active">进阶知识 <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a href="/advance/browser.html" class="sidebar-item" aria-label="浏览器"><!--[--><!--]--> 浏览器 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advance/network.html" class="router-link-active router-link-exact-active router-link-active sidebar-item active" aria-label="网络"><!--[--><!--]--> 网络 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/advance/network.html#单工、半双工和全双工通信" class="router-link-active router-link-exact-active sidebar-item" aria-label="单工、半双工和全双工通信"><!--[--><!--]--> 单工、半双工和全双工通信 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advance/network.html#udp" class="router-link-active router-link-exact-active sidebar-item" aria-label="UDP"><!--[--><!--]--> UDP <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advance/network.html#tcp" class="router-link-active router-link-exact-active sidebar-item" aria-label="TCP"><!--[--><!--]--> TCP <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/advance/network.html#建立三次握手" class="router-link-active router-link-exact-active sidebar-item" aria-label="建立三次握手"><!--[--><!--]--> 建立三次握手 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advance/network.html#为什么需要三次-两次和四次可以吗" class="router-link-active router-link-exact-active sidebar-item" aria-label="为什么需要三次，两次和四次可以吗？"><!--[--><!--]--> 为什么需要三次，两次和四次可以吗？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advance/network.html#断开连接四次挥手" class="router-link-active router-link-exact-active sidebar-item" aria-label="断开连接四次挥手"><!--[--><!--]--> 断开连接四次挥手 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advance/network.html#为什么客户端最后还要等待-2msl" class="router-link-active router-link-exact-active sidebar-item" aria-label="为什么客户端最后还要等待 2MSL"><!--[--><!--]--> 为什么客户端最后还要等待 2MSL <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advance/network.html#为什么建立连接是三次握手-关闭连接确是四次挥手呢" class="router-link-active router-link-exact-active sidebar-item" aria-label="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"><!--[--><!--]--> 为什么建立连接是三次握手，关闭连接确是四次挥手呢？ <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/advance/network.html#tcp-ip-网络模型" class="router-link-active router-link-exact-active sidebar-item" aria-label="TCP/IP 网络模型"><!--[--><!--]--> TCP/IP 网络模型 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advance/network.html#osi-七层模型" class="router-link-active router-link-exact-active sidebar-item" aria-label="OSI 七层模型"><!--[--><!--]--> OSI 七层模型 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advance/network.html#dns" class="router-link-active router-link-exact-active sidebar-item" aria-label="DNS"><!--[--><!--]--> DNS <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advance/network.html#cdn" class="router-link-active router-link-exact-active sidebar-item" aria-label="CDN"><!--[--><!--]--> CDN <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advance/network.html#http" class="router-link-active router-link-exact-active sidebar-item" aria-label="HTTP"><!--[--><!--]--> HTTP <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/advance/network.html#请求报文" class="router-link-active router-link-exact-active sidebar-item" aria-label="请求报文"><!--[--><!--]--> 请求报文 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advance/network.html#响应报文" class="router-link-active router-link-exact-active sidebar-item" aria-label="响应报文"><!--[--><!--]--> 响应报文 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advance/network.html#http1-1" class="router-link-active router-link-exact-active sidebar-item" aria-label="HTTP1.1"><!--[--><!--]--> HTTP1.1 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advance/network.html#http2" class="router-link-active router-link-exact-active sidebar-item" aria-label="HTTP2"><!--[--><!--]--> HTTP2 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advance/network.html#http3" class="router-link-active router-link-exact-active sidebar-item" aria-label="HTTP3"><!--[--><!--]--> HTTP3 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advance/network.html#状态码" class="router-link-active router-link-exact-active sidebar-item" aria-label="状态码"><!--[--><!--]--> 状态码 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/advance/network.html#get-post" class="router-link-active router-link-exact-active sidebar-item" aria-label="GET/POST"><!--[--><!--]--> GET/POST <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advance/network.html#https" class="router-link-active router-link-exact-active sidebar-item" aria-label="HTTPS"><!--[--><!--]--> HTTPS <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advance/network.html#tls-ssl-的工作原理" class="router-link-active router-link-exact-active sidebar-item" aria-label="TLS/SSL 的工作原理"><!--[--><!--]--> TLS/SSL 的工作原理 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advance/network.html#安全" class="router-link-active router-link-exact-active sidebar-item" aria-label="安全"><!--[--><!--]--> 安全 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/advance/network.html#xss-攻击" class="router-link-active router-link-exact-active sidebar-item" aria-label="XSS 攻击"><!--[--><!--]--> XSS 攻击 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advance/network.html#csrf-攻击" class="router-link-active router-link-exact-active sidebar-item" aria-label="CSRF 攻击"><!--[--><!--]--> CSRF 攻击 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advance/network.html#点击劫持" class="router-link-active router-link-exact-active sidebar-item" aria-label="点击劫持"><!--[--><!--]--> 点击劫持 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advance/network.html#对称加密" class="router-link-active router-link-exact-active sidebar-item" aria-label="对称加密"><!--[--><!--]--> 对称加密 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advance/network.html#非对称加密" class="router-link-active router-link-exact-active sidebar-item" aria-label="非对称加密"><!--[--><!--]--> 非对称加密 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advance/network.html#中间人攻击、第三方认证、数字签名" class="router-link-active router-link-exact-active sidebar-item" aria-label="中间人攻击、第三方认证、数字签名"><!--[--><!--]--> 中间人攻击、第三方认证、数字签名 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/advance/network.html#实现登录" class="router-link-active router-link-exact-active sidebar-item" aria-label="实现登录"><!--[--><!--]--> 实现登录 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advance/network.html#单点登录" class="router-link-active router-link-exact-active sidebar-item" aria-label="单点登录"><!--[--><!--]--> 单点登录 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advance/network.html#正反向代理" class="router-link-active router-link-exact-active sidebar-item" aria-label="正反向代理"><!--[--><!--]--> 正反向代理 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advance/network.html#graphql-与-restful-的区别-它有什么优点" class="router-link-active router-link-exact-active sidebar-item" aria-label="GraphQL 与 Restful 的区别，它有什么优点？"><!--[--><!--]--> GraphQL 与 Restful 的区别，它有什么优点？ <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a href="/advance/typescript.html" class="sidebar-item" aria-label="TS"><!--[--><!--]--> TS <!--[--><!--]--></a><!----></li><li><a href="/advance/design.html" class="sidebar-item" aria-label="设计模式"><!--[--><!--]--> 设计模式 <!--[--><!--]--></a><!----></li><li><a href="/advance/data.html" class="sidebar-item" aria-label="数据结构&amp;算法"><!--[--><!--]--> 数据结构&amp;算法 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><h1 id="网络" tabindex="-1"><a class="header-anchor" href="#网络" aria-hidden="true">#</a> 网络</h1><h2 id="单工、半双工和全双工通信" tabindex="-1"><a class="header-anchor" href="#单工、半双工和全双工通信" aria-hidden="true">#</a> 单工、半双工和全双工通信</h2><ul><li>单工数据传输只支持数据在一个方向上传输;</li><li>半双工数据传输允许数据在两个方向上传输，但是，在某一时刻，只允许数据在一个方向上传输，它实际上是一种切换方向的单工通信；</li><li>全双工数据通信允许数据同时在两个方向上传输，因此，全双工通信是两个单工通信方式的结合，它要求发送设备和接收设备都有独立的接收和发送能力。</li></ul><h2 id="udp" tabindex="-1"><a class="header-anchor" href="#udp" aria-hidden="true">#</a> UDP</h2><p>UDP 协议是面向无连接的，也就是说不需要在正式传递数据之前先连接起双方。然后 UDP 协议只是数据报文的搬运工，不保证有序且不丢失的传递到对端，并且 UDP 协议也没有任何控制流量的算法，总的来说 UDP 相较于 TCP 更加的轻便</p><ol><li>面向无连接 UDP 是不需要和 TCP 一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了，并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作</li><li>不可靠性 不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠</li><li>高效 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的</li><li>传播方式 UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能</li><li>使用场景 直播、网络游戏</li></ol><h2 id="tcp" tabindex="-1"><a class="header-anchor" href="#tcp" aria-hidden="true">#</a> TCP</h2><p>TCP 的全称是传输控制协议，是一种面向连接的、可靠的、基于字节流的传输层通信协议。TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构。</p><h3 id="建立三次握手" tabindex="-1"><a class="header-anchor" href="#建立三次握手" aria-hidden="true">#</a> 建立三次握手</h3><ol><li>客户端发送 syn 包(Seq=x)到服务器，并进入 SYN_SEND 状态，等待服务器确认。</li><li>服务器收到 syn 包，必须确认客户的 SYN（ack=x+1），同时自己也发送一个 SYN 包（Seq=y），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态。（服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态）</li><li>客户端收到服务器的 SYN ＋ ACK 包，向服务器发送确认包 ACK(ack=y+1)，此包发送完毕，客户端和服务器进入 ESTABLISHED 状态，完成三次握手。（当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功）</li></ol><p>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP 连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。</p><h3 id="为什么需要三次-两次和四次可以吗" tabindex="-1"><a class="header-anchor" href="#为什么需要三次-两次和四次可以吗" aria-hidden="true">#</a> 为什么需要三次，两次和四次可以吗？</h3><p>防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误</p><p>建立连接的过程是利用客户服务器模式，假设主机 A 为客户端，主机 B 为服务器端。</p><ul><li>采用三次握手是为了防止失效的连接请求报文段突然又传送到主机 B，因而产生错误。失效的连接请求报文段是指：主机 A 发出的连接请求没有收到主机 B 的确认，于是经过一段时间后，主机 A 又重新向主机 B 发送连接请求，且建立成功，顺序完成数据传输。考虑这样一种特殊情况，主机 A 第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机 B，主机 B 以为是主机 A 又发起的新连接，于是主机 B 同意连接，并向主机 A 发回确认，但是此时主机 A 根本不会理会，主机 B 就一直在等待主机 A 发送数据，导致主机 B 的资源浪费。</li><li>采用两次握手不行，原因就是上面说的失效的连接请求的特殊情况。而在三次握手中， client 和 server 都有一个发 syn 和收 ack 的过程， 双方都是发后能收， 表明通信则准备工作 OK.</li><li>为什么不是四次握手呢？ 大家应该知道通信中著名的蓝军红军约定， 这个例子说明， 通信不可能 100%可靠， 而上面的三次握手已经做好了通信的准备工作， 再增加握手， 并不能显著提高可靠性， 而且也没有必要。</li></ul><h3 id="断开连接四次挥手" tabindex="-1"><a class="header-anchor" href="#断开连接四次挥手" aria-hidden="true">#</a> 断开连接四次挥手</h3><p>数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于 ESTABLISHED 状态，假设客户端主动关闭，服务器被动关闭。</p><ol><li>客户端发送一个 FIN，用来关闭客户端到服务器的数据传送，也就是客户端告诉服务器：我已经不 会再给你发数据了(当然，在 fin 包之前发送出去的数据，如果没有收到对应的 ack 确认报文，客户端依然会重发这些数据)，但是，此时客户端还可 以接受数据。 FIN=1，其序列号为 seq=u（等于前面已经传送过来的数据的最后一个字节的序号加 1），此时，客户端进入 FIN-WAIT-1（终止等待 1）状态。 TCP 规定，FIN 报文段即使不携带数据，也要消耗一个序号。</li><li>服务器收到 FIN 包后，发送一个 ACK 给对方并且带上自己的序列号 seq，确认序号为收到序号+1（与 SYN 相同，一个 FIN 占用一个序号）。此时，服务端就进入了 CLOSE-WAIT（关闭等待）状态。TCP 服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个 CLOSE-WAIT 状态持续的时间。 此时，客户端就进入 FIN-WAIT-2（终止等待 2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</li><li>服务器发送一个 FIN，用来关闭服务器到客户端的数据传送，也就是告诉客户端，我的数据也发送完了，不会再给你发数据了。由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为 seq=w，此时，服务器就进入了 LAST-ACK（最后确认）状态，等待客户端的确认。</li><li>主动关闭方收到 FIN 后，发送一个 ACK 给被动关闭方，确认序号为收到序号+1，此时，客户端就进入了 TIME-WAIT（时间等待）状态。注意此时 TCP 连接还没有释放，必须经过 2∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的 TCB 后，才进入 CLOSED 状态。 服务器只要收到了客户端发出的确认，立即进入 CLOSED 状态。同样，撤销 TCB 后，就结束了这次的 TCP 连接。可以看到，服务器结束 TCP 连接的时间要比客户端早一些。 至此，完成四次挥手。</li></ol><h3 id="为什么客户端最后还要等待-2msl" tabindex="-1"><a class="header-anchor" href="#为什么客户端最后还要等待-2msl" aria-hidden="true">#</a> 为什么客户端最后还要等待 2MSL</h3><p><code>MSL（Maximum Segment Lifetime）</code>，TCP 允许不同的实现可以设置不同的 MSL 值。</p><ol><li>保证客户端发送的最后一个 ACK 报文能够到达服务器，因为这个 ACK 报文可能丢失，站在服务器的角度看来，我已经发送了 FIN+ACK 报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个 2MSL 时间段内收到这个重传的报文，接着给出回应报文，并且会重启 2MSL 计时器。</li><li>防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个 2MSL 时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</li></ol><h3 id="为什么建立连接是三次握手-关闭连接确是四次挥手呢" tabindex="-1"><a class="header-anchor" href="#为什么建立连接是三次握手-关闭连接确是四次挥手呢" aria-hidden="true">#</a> 为什么建立连接是三次握手，关闭连接确是四次挥手呢？</h3><p>建立连接的时候， 服务器在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。</p><p>而关闭连接时，服务器收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接，因此，己方 ACK 和 FIN 一般都会分开发送，从而导致多了一次。</p><h2 id="tcp-ip-网络模型" tabindex="-1"><a class="header-anchor" href="#tcp-ip-网络模型" aria-hidden="true">#</a> TCP/IP 网络模型</h2><ol><li><p>TCP/IP 模型是一系列网络协议的总称，这些协议的目的是使得计算机之间可以进行信息交换，</p></li><li><p>TCP/IP 模型五层架构从下到上分别是物理层，链路层，网络层，传输层，应用层</p></li></ol><ul><li>物理层：确保数据可以在各种物理媒介上进行传输，为数据的传输提供可靠的环境。</li><li>链路层：负责建立电路连接，是整个网络的物理基础，典型的协议包括以太网，ADSL 等，</li><li>网络层：负责分配地址和传送二进制数据，主要协议是 IP 协议，</li><li>传输层：负责传送文本数据，主要协议是 TCP</li><li>应用层：负责传送各种最终形态的数据，是直接与用户信息打交道的层，主要协议是 http，ftp 等</li></ul><h2 id="osi-七层模型" tabindex="-1"><a class="header-anchor" href="#osi-七层模型" aria-hidden="true">#</a> OSI 七层模型</h2><ul><li>应用层：各种应用软件，常用协议 HTTP，SSH，FTP</li><li>表示层：数据格式标识，基本压缩加密功能</li><li>会话层：控制应用程序之间会话能力，区分不同的进程</li><li>传输层：提供端对端的接口，TCP，UDP-</li><li>网络层：定义 IP 地址，定义路由功能，建立主机到主机的通信</li><li>数据链路层：将比特封装成数据帧并传递</li><li>物理层：网络连接介质，如网线、光缆，数据在其中以比特为单位传输，二进制的数据形式在物理媒体上传输数据</li></ul><h2 id="dns" tabindex="-1"><a class="header-anchor" href="#dns" aria-hidden="true">#</a> DNS</h2><ul><li>概念： DNS 是域名系统 (Domain Name System) 的缩写，提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。它是一个由分层的 DNS 服务器组成的分布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的 IP 数串。</li><li>作用： 将域名解析为 IP 地址，客户端向 DNS 服务器（DNS 服务器有自己的 IP 地址）发送域名查询请求，DNS 服务器告知客户机 Web 服务器的 IP 地址。</li><li>优化： 缓存、负载均衡</li></ul><p>DNS 服务器解析域名的过程(递归)：</p><ol><li>首先会在浏览器的缓存中查找对应的 IP 地址，如果查找到直接返回，若找不到继续下一步</li><li>将请求发送给本地 DNS 服务器，在本地域名服务器缓存中查询，如果查找到，就直接将查找结果返回，若找不到继续下一步</li><li>本地 DNS 服务器向根域名服务器发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址</li><li>本地 DNS 服务器向顶级域名服务器发送请求，接受请求的服务器查询自己的缓存，如果有记录，就返回查询结果，如果没有就返回相关的下一级的权威域名服务器的地址</li><li>本地 DNS 服务器向权威域名服务器发送请求，域名服务器返回对应的结果</li><li>本地 DNS 服务器将返回结果保存在缓存中，便于下次使用</li><li>本地 DNS 服务器将返回结果返回给浏览器</li></ol><h2 id="cdn" tabindex="-1"><a class="header-anchor" href="#cdn" aria-hidden="true">#</a> CDN</h2><p>CDN 的全称是 Content Delivery Network，即内容分发网络。</p><p>CDN 的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应。</p><p>对于 CDN 加载静态资源需要注意 CDN 域名要与主站不同，否则每次请求都会带上主站的 Cookie。</p><h2 id="http" tabindex="-1"><a class="header-anchor" href="#http" aria-hidden="true">#</a> HTTP</h2><blockquote><p>超文本传输协议（hypertext transfer protocol），连接客户端，网关和服务器，HTTP 是一个基于 TCP/IP 通信协议来传递数据</p></blockquote><p>简单快速、灵活、无连接、无状态 HTTP 三点注意事项：</p><ol><li>HTTP 是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li></ol><ul><li>可通过设置自身属性 Keep-Alive 解决</li></ul><ol start="2"><li>HTTP 是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过 HTTP 发送。客户端以及服务器指定使用适合的 MIME-type 内容类型。</li><li>HTTP 是无状态：HTTP 协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li></ol><ul><li>只能通过 cookie 和 session 来做贮存</li></ul><h3 id="请求报文" tabindex="-1"><a class="header-anchor" href="#请求报文" aria-hidden="true">#</a> 请求报文</h3><p>一个 HTTP 请求报文由请求行（request line）、请求头（header）、空行和请求数据 4 个部分组成</p><ul><li><p>请求行组成：</p><ul><li>请求方法：GET、POST、HEAD、PUT、DELETE、TRACE、OPTIONS、CONNECT、PATCH</li><li>URL</li><li>协议版本</li></ul></li><li><p>常见请求头：</p><ul><li>User-Agent：产生请求的浏览器类型。</li><li>Accept：客户端可识别的内容类型列表。</li><li>Host：请求的主机名，允许多个域名同处一个 IP 地址，即虚拟主机。</li><li>Content-Type：请求体的 MIME 类型 （用于 POST 和 PUT 请求中）。如：Content-Type: application/x-www-form-urlencoded</li></ul></li></ul><h3 id="响应报文" tabindex="-1"><a class="header-anchor" href="#响应报文" aria-hidden="true">#</a> 响应报文</h3><p>包括：状态行、响应头、空行、响应正文</p><h3 id="http1-1" tabindex="-1"><a class="header-anchor" href="#http1-1" aria-hidden="true">#</a> HTTP1.1</h3><ol><li>长连接： HTTP/1.1 支持长连接和请求的流水线，在一个 TCP 连接上可以传送多个 HTTP 请求，避免了因为多次建立 TCP 连接的时间消耗和延时</li><li>缓存处理： HTTP/1.1 引入 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等新的请求头来控制缓存</li><li>带宽优化及网络连接的使用： HTTP1.1 则在请求头引入了 range 头域，支持断点续传功能</li><li>Host 头处理： 在 HTTP/1.0 中认为每台服务器都有唯一的 IP 地址，但随着虚拟主机技术的发展，多个主机共享一个 IP 地址愈发普遍，HTTP1.1 的请求消息和响应消息都应支持 Host 头域，且请求消息中如果没有 Host 头域会 400 错误</li></ol><h3 id="http2" tabindex="-1"><a class="header-anchor" href="#http2" aria-hidden="true">#</a> HTTP2</h3><ol><li>多路复用： 即多个请求都通过一个 TCP 连接并发地完成 <ul><li>原理： HTTP/2 引入了一个二进制分帧层，客户端和服务端进行传输时，数据会先经过二进制分帧层处理，转化为一个个带有请求 ID 的帧，这些帧在传输完成后根据 ID 组合成对应的数据</li></ul></li><li>服务端推送： 服务端能够主动把资源推送给客户端</li><li>新的二进制格式： HTTP/2 采用二进制格式传输数据，相比于 HTTP/1.1 的文本格式，二进制格式具有更好的解析性和拓展性</li><li>header 压缩： HTTP/2 压缩消息头，减少了传输数据的大小</li></ol><h3 id="http3" tabindex="-1"><a class="header-anchor" href="#http3" aria-hidden="true">#</a> HTTP3</h3><p>TCP 改基于 UDP 的 QUIC，新增功能：多路复用、0-RTT、使用 TLS1.3 加密、流量控制、有序交付、重传等</p><p>特性：</p><ol><li>连接迁移 tcp里面的四元组，一条tcp的唯一性标识，是由源IP，源端口，目的IP,目的端口，四元组标识。源IP，源端口一般比较稳定，但是目的IP,目的端口会由于网络元素等原因发生改变，一旦改变，那么此条tcp连接就会断开。</li></ol><p>由于QUIC基于UDP协议，所以一条UDP协议不再由四元组标识，而是以客户端随机产生的一个64位数字作为ID标识。只要ID不变，那么这条UDP就会存在，维持连接，上层业务逻辑就感受不到变化。 2. 无队头阻塞 http2.0的多路复用正好解决了http层的队头阻塞，但是tcp的队头阻塞依然存在。因为当数据包超时确认或者丢失，会等待重传，因此会阻塞当前窗口向右滑动，造成阻塞。</p><p>而QUIC是基于udp的，创新点在于QUIC依靠一个严格的单调递增的packet序列，一个数据包里面还会有streamID和streamoffset偏移量，即使中途发生丢包或者超时确认，后面的数据包不会等待，等到接收完之后根据ID和offset即可完成重新拼装，从而避免了这种问题 3. 自定义的佣塞控制 tcp协议是在传输层，默认存在于系统中，而QUIC在应用层，当想要依据实际情况来重定义拥塞算法的时候，QUIC显然更加灵活。Google提出了cubic和newreno提供了许多可供编程的接口。当然，和tcp一样，也是默认采用cubic算法。 4. 前向安全和前向纠错 Google给QUIC加上了这个机制：每发送一组数据之后，就对这组数据进行异或运算（效率高），并将结果也发送出去，那么接收方就有两份数据版本，可以对初始数据进行纠错和校验。以此保证了可靠性。</p><h3 id="状态码" tabindex="-1"><a class="header-anchor" href="#状态码" aria-hidden="true">#</a> 状态码</h3><ul><li>1xx (Informational): 收到请求，正在处理</li><li>2xx (Successful): 该请求已成功收到，理解并接受 <ul><li>200 OK：客户端发送给服务器的请求被正常处理并返回</li><li>204 No content，表示请求成功，但响应报文不含实体的主体部分</li><li>205 Reset Content，表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容</li><li>206 Partial Content，进行范围请求</li></ul></li><li>3xx (Redirection): 重定向 <ul><li>301 Moved Permanently：永久重定向，请求的网页已永久移动到新位置。 服务器返回此响应时，会自动将请求者转到新位置</li><li>302 Moved Permanently：临时重定向，请求的网页已临时移动到新位置。服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求</li><li>303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源</li><li>304 Not Modified：未修改，自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容</li><li>307 temporary redirect，临时重定向，和 302 含义类似，但是期望客户端保持请求方法不变向新的地址发出请求</li></ul></li><li>4xx (Client Error): 该请求包含错误的语法或不能为完成 <ul><li>400 Bad Request：错误请求，服务器不理解请求的语法，常见于客户端传参错误</li><li>401 Unauthorized：未授权，表示发送的请求需要有通过 HTTP 认证的认证信息，常见于客户端未登录</li><li>403 Forbidden：禁止，服务器拒绝请求，常见于客户端权限不足</li><li>404 Not Found：未找到，服务器找不到对应资源</li></ul></li><li>5xx (Server Error): 服务器错误 <ul><li>500 Inter Server Error：服务器内部错误，服务器遇到错误，无法完成请求</li><li>501 Not Implemented：尚未实施，服务器不具备完成请求的功能</li><li>502 Bad Gateway：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</li><li>503 service unavailable：服务不可用，服务器目前无法使用（处于超载或停机维护状态）。通常是暂时状态</li></ul></li></ul><h2 id="get-post" tabindex="-1"><a class="header-anchor" href="#get-post" aria-hidden="true">#</a> GET/POST</h2><ol><li>get 参数通过 url 传递，post 放在 request body 中。</li><li>get 请求在 url 中传递的参数是有长度限制的，而 post 没有。</li><li>get 比 post 更不安全，因为参数直接暴露在 url 中，所以不能用来传递敏感信息。</li><li>get 请求只能进行 url 编码，而 post 支持多种编码方式</li><li>get 请求会浏览器主动 cache，而 post 不会。</li><li>get 请求参数会被完整保留在浏览历史记录里，而 post 中的参数不会被保留。</li><li>GET 和 POST 本质上就是 TCP 链接，并无差别。但是由于 HTTP 的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。</li></ol><ul><li>应用场景： <ul><li>Get 多用于无副作用，幂等的场景，例如搜索关键字。</li><li>Post 多用于副作用，不幂等的场景，例如注册</li></ul></li><li>副作用：对服务器上的资源做改变</li><li>幂等：发送 M 和 N 次请求（两者不相同且都大于 1），服务器上资源的状态一致</li></ul><h2 id="https" tabindex="-1"><a class="header-anchor" href="#https" aria-hidden="true">#</a> HTTPS</h2><blockquote><p>超文本传输安全协议（Hypertext Transfer Protocol Secure，简称：HTTPS）是一种通过计算机网络进行安全通信的传输协议。</p></blockquote><p>HTTPS 经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。</p><p>区别：</p><ul><li>HTTPS 使用 443 端口，而 HTTP 使用 80</li><li>HTTPS 需要申请证书</li><li>HTTP 是超文本传输协议，是明文传输；HTTPS 是经过 SSL 加密的协议，传输更安全</li><li>HTTPS 比 HTTP 慢，因为 HTTPS 除了 TCP 握手的三个包，还要加上 SSL 握手的九个包</li></ul><p>HTTP 协议采用明文传输信息，存在信息窃听、信息篡改和信息劫持的风险，而协议 TLS/SSL 具有身份验证、信息加密和完整性校验的功能，可以避免此类问题发生。</p><p>安全层的主要职责就是对发起的 HTTP 请求的数据进行加密操作 和 对接收到的 HTTP 的内容进行解密操作</p><h2 id="tls-ssl-的工作原理" tabindex="-1"><a class="header-anchor" href="#tls-ssl-的工作原理" aria-hidden="true">#</a> TLS/SSL 的工作原理</h2><blockquote><p>TLS/SSL 全称安全传输层协议（Transport Layer Security）, 是介于 TCP 和 HTTP 之间的一层安全协议，不影响原有的 TCP 协议和 HTTP 协议，所以使用 HTTPS 基本上不需要对 HTTP 页面进行太多的改造。</p></blockquote><p>TLS/SSL 的功能实现主要依赖三类基本算法：散列函数 hash、对称加密、非对称加密。这三类算法的作用如下：</p><ul><li>基于散列函数验证信息的完整性</li><li>对称加密算法采用协商的秘钥对数据加密</li><li>非对称加密实现身份认证和秘钥协商</li></ul><h2 id="安全" tabindex="-1"><a class="header-anchor" href="#安全" aria-hidden="true">#</a> 安全</h2><h3 id="xss-攻击" tabindex="-1"><a class="header-anchor" href="#xss-攻击" aria-hidden="true">#</a> XSS 攻击</h3><blockquote><p>跨域脚本攻击（cross-site scripting）</p></blockquote><ul><li>原理： 往 Web 页面里插入恶意 Script 代码</li><li>类型： <ul><li>持久：攻击的代码被服务端写入进数据库中，这种攻击危害性很大，因为如果网站访问量很大的话，就会导致大量正常访问页面的用户都受到攻击</li><li>非持久：通过修改 URL 参数的方式加入攻击代码，诱导用户访问链接从而进行攻击</li></ul></li><li>防御措施： <ul><li>转义字符： <ul><li>HTML：对以下这些字符进行转义：<div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token operator">&amp;</span>：<span class="token operator">&amp;</span>amp<span class="token punctuation">;</span>
<span class="token operator">&lt;</span>：<span class="token operator">&amp;</span>alt<span class="token punctuation">;</span>
<span class="token operator">&gt;</span>：<span class="token operator">&amp;</span>gt<span class="token punctuation">;</span>
&#39;：<span class="token operator">&amp;</span>#x27<span class="token punctuation">;</span>
&quot;：<span class="token operator">&amp;</span>quot<span class="token punctuation">;</span>
<span class="token operator">/</span>：<span class="token operator">&amp;</span>#x2F<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li>Javascript：把所有非字母、数字的字符都转义成小于 256 的 ASCII 字符；</li><li>URL：使用 Javascript 的 encodeURIComponent()方法对用户的输入进行编码，该方法会编码如下字符：,/?😡&amp;=+$ #</li><li>CSP： 建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截是由浏览器自己实现的。我们可以通过这种方式来尽量减少 XSS 攻击 通常可以通过两种方式来开启 CSP： <ol><li>设置 HTTP Header 中的 Content-Security-Policy</li><li>设置 meta 标签的方式 <meta http-equiv="Content-Security-Policy"></li></ol></li></ul></li></ul></li></ul><h3 id="csrf-攻击" tabindex="-1"><a class="header-anchor" href="#csrf-攻击" aria-hidden="true">#</a> CSRF 攻击</h3><blockquote><p>跨站请求伪造（Cross-site request forgery）</p></blockquote><ul><li><p>原理： 攻击者构造出一个后端请求地址，诱导用户点击或者通过某些途径自动发起请求。如果用户是在登录状态下的话，后端就以为是用户在操作，从而进行相应的逻辑。</p></li><li><p>防御措施：</p><ul><li>可以对 Cookie 设置 SameSite 属性</li><li>Token 验证（服务器下发一个随机 Token）</li><li>Referer 验证（简单易行，但 referer 可能被改变）</li><li>隐藏令牌（跟 Token 验证差不多，把令牌存到 header 中）</li></ul></li></ul><h3 id="点击劫持" tabindex="-1"><a class="header-anchor" href="#点击劫持" aria-hidden="true">#</a> 点击劫持</h3><ul><li>原理：是一种视觉欺骗的攻击手段。攻击者将需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击。</li><li>防御： <ul><li>X-FRAME-OPTIONS 响应头： <ul><li>DENY，表示页面不允许通过 iframe 的方式展示</li><li>SAMEORIGIN，表示页面可以在相同域名下通过 iframe 的方式展示</li><li>ALLOW-FROM，表示页面可以在指定来源的 iframe 中展示</li></ul></li><li>JS 防御： <ul><li>通过 self == top 判断</li></ul></li></ul></li></ul><h3 id="对称加密" tabindex="-1"><a class="header-anchor" href="#对称加密" aria-hidden="true">#</a> 对称加密</h3><p>客户端和服务器公用一个密匙用来对消息加解密</p><p>对称加密就是两边拥有相同的秘钥，两边都知道如何将密文加密解密。</p><p>这种加密方式固然很好，但是问题就在于如何让双方知道秘钥。因为传输数据都是走的网络，如果将秘钥通过网络的方式传递的话，一旦秘钥被截获就没有加密的意义的。</p><p>常见的对称加密算法有 AES-CBC、DES、3DES、AES-GCM 等</p><h3 id="非对称加密" tabindex="-1"><a class="header-anchor" href="#非对称加密" aria-hidden="true">#</a> 非对称加密</h3><p>有公钥私钥之分，公钥所有人都可以知道，可以将数据用公钥加密，但是将数据解密必须使用私钥解密，私钥只有分发公钥的一方才知道。</p><p>这种加密方式就可以完美解决对称加密存在的问题。假设现在两端需要使用对称加密，那么在这之前，可以先使用非对称加密交换秘钥。</p><p>简单流程如下：首先服务端将公钥公布出去，那么客户端也就知道公钥了。接下来客户端创建一个秘钥，然后通过公钥加密并发送给服务端，服务端接收到密文以后通过私钥解密出正确的秘钥，这时候两端就都知道秘钥是什么了。</p><p>常见的非对称加密算法有 RSA、ECC、DH 等</p><h3 id="中间人攻击、第三方认证、数字签名" tabindex="-1"><a class="header-anchor" href="#中间人攻击、第三方认证、数字签名" aria-hidden="true">#</a> 中间人攻击、第三方认证、数字签名</h3><p>因为我们没有办法确定我们得到的公钥就一定是安全的公钥。可能存在一个中间人，截取 了对方发给我们的公钥，然后将他自己的公钥发送给我们，当我们使用他的公钥加密后发送的信息，就可以被他用自己的私钥 解密。</p><p>然后他伪装成我们以同样的方法向对方发送信息，这样我们的信息就被窃取了，然而我们自己还不知道。</p><p>为了解决这样的问题，我们可以使用数字证书的方式，首先我们使用一种 Hash 算法来对我们的公钥和其他信息进行加密生成 一个信息摘要，然后让有公信力的认证中心（简称 CA ）用它的私钥对消息摘要加密，形成签名。最后将原始的信息和签名合 在一起，称为数字证书。</p><p>当接收方收到数字证书的时候，先根据原始信息使用同样的 Hash 算法生成一个摘要，然后使用公证 处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和我们生成的摘要进行对比，就能发现我们得到的信息是否被更改 了。</p><p>这个方法最要的是认证中心的可靠性，一般浏览器里会内置一些顶层的认证中心的证书，相当于我们自动信任了他们，只有 这样我们才能保证数据的安全。</p><h2 id="实现登录" tabindex="-1"><a class="header-anchor" href="#实现登录" aria-hidden="true">#</a> 实现登录</h2><p>Cookie，Session 和 Token 都是为了能够实现客户端与服务器间的状态维持。其中：</p><ul><li>Cookie 存储于客户端，主要用于一些简短信息的存储； HTTP 协议中的 Cookie 包括 Web Cookie 和浏览器 Cookie，它是服务器发送到 Web 浏览器的一小块数据。服务器发送到浏览器的 Cookie，浏览器会进行存储、</li><li>Session 存储于服务器端，维护了客户端的相关信息列表，并且通过一个唯一的身份标识 sessionId 识别各个客户端。 客户端请求服务端，服务端会为这次请求开辟一块内存空间，这个对象便是 Session 对象，存储结构为 ConcurrentHashMap。Session 弥补了 HTTP 无状态特性，服务器可以利用 Session 存储客户端在同一个会话期间的一些操作记录。</li><li>Token 存储于客户端，其结构紧凑且自带验证功能，很好地解决了 Session 无法水平扩展服务器的局限，实现了服务器无状态但通信具备却状态维持功能。通常使用 JWT（JSON Web Token） 作为 Token 的具体实现方式。</li></ul><h2 id="单点登录" tabindex="-1"><a class="header-anchor" href="#单点登录" aria-hidden="true">#</a> 单点登录</h2><p>单点登录是指在同一帐号平台下的多个应用系统中，用户只需登录一次，就可访问所有相互信任的应用系统。比如你在网页中登录了百度云盘，随后你再去贴吧发帖 是不需要二次登录的。</p><p>单点登录的本质就是在多个应用系统中共享登录状态。如果用户的登录状态是记录在 Session 中的，要实现共享登录状态，就要先共享 Session，比如可以将 Session 序列化到 Redis 中，让多个应用系统共享同一个 Redis，直接读取 Redis 来获取 Session。</p><p>因为不同的应用系统有着不同的域名，尽管 Session 共享了，但是一个企业不同应用的域名不同，依然可能出现跨站or跨域。</p><p>前端方面的实现方式:</p><ul><li>父域 Cookie</li><li>认证中心</li><li>LocalStorage 跨域</li></ul><h2 id="正反向代理" tabindex="-1"><a class="header-anchor" href="#正反向代理" aria-hidden="true">#</a> 正反向代理</h2><p>代理其本质上可以理解为中介。当A和B不方便进行交互时，往往会引入一个中间角色C，那么C便是中介，便是代理。 正向代理服务器通常位于客户端和服务器之间，类似一个跳板机，通过代理服务器可以访问到目标服务器。 正向代理时，通常，客户端发送对目标服务器的请求，代理服务器在中间将请求转发给目标服务器，并将结果返回给客户端。 反向代理与正向代理恰好相反，代理服务位于服务器端。 对客户端来说，反向代理服务器就好像是目标服务器。反向代理服务器接收客户端发来的请求，然后将其分发到内网的服务器，并将内网服务器返回的结果返回给客户端。 整个过程客户端并不会感知到反向代理后面的服务，也不需要客户端做任何设置，只需要把反向代理服务器当成真正的服务器就行。</p><h2 id="graphql-与-restful-的区别-它有什么优点" tabindex="-1"><a class="header-anchor" href="#graphql-与-restful-的区别-它有什么优点" aria-hidden="true">#</a> GraphQL 与 Restful 的区别，它有什么优点？</h2><p>QraphQL是对后端REST API向业务层的聚合与裁剪，REST更关注对业务细粒度的拆分与重用。 其实就是增加了一个中间层对前端的请求和响应做预处理和后处理，前端的工作少了，后端的工作也没多，却加入了中端的依赖，好处是避免前端和后端的多次远距离的交互。 而graphql存在一个很难控制的问题就是查询复杂度。在开发过程中需要把控好解析粒度，而就目前主流关系型数据库，restful api依旧是最好的选择。graphql准确的说在查询图结构数据时更有优势，这也是其名称的主意。</p></div><!--[--><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: xiaodigen@yzgong.com">肖笛根</span><!----><!--]--><!--]--></span></div></footer><nav class="page-nav"><p class="inner"><span class="prev"><a href="/advance/browser.html" class="" aria-label="浏览器"><!--[--><!--]--> 浏览器 <!--[--><!--]--></a></span><span class="next"><a href="/advance/typescript.html" class="" aria-label="TS"><!--[--><!--]--> TS <!--[--><!--]--></a></span></p></nav><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/app.1c1e1be9.mjs" defer></script>
  </body>
</html>
