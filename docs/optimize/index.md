## 页面埋点

- PV / UV
- 停留时长
- 流量来源
- 用户交互

分类：

- 手写埋点：自主选择需要监控的数据然后在相应的地方写入代码。这种方式的灵活性很大，但是唯一的缺点就是工作量较大，每个需要监控的地方都得插入代码
- 无埋点：统计所有的事件并且定时上报。这种方式虽然没有前一种方式繁琐了，但是因为统计的是所有事件，所以还需要后期过滤出需要的数据

## 性能监控

对于性能监控来说，其实我们只需要调用 `performance.getEntriesByType('navigation')` 这行代码就行了

## 性能优化

### 资源

- 减少 http 请求次数和传输报文大小
- CSS Sprite（雪碧图，图片精灵）技术
- 图片懒加载（延迟加载）技术
- 音视频文件取消预加载（preload='none'），可以增加第一次渲染页面的速度，需要播放的时候在加载
- 客户端和服务器端的数据传输尽可能基于 JSON 格式完成，XML 格式比 JSON 格式要大一些
- 把页面中的 CSS/JS/图片等文件进行合并压缩
- 图片地图：对于多次调取使用的图片（背景图），尽可能把它提取成公共样式，而不是重新设置 background
- 图片 Base64 用 base64 码代表图片，减少 http 请求，增加浏览器渲染速度 但是代码恶心针对一些个别的加载速度很慢的图片可以使用

### 网络

- 把不经常更改的静态资源（js 库、图片等）做缓存处理（一般做的是 304 或者 Etag 等协商缓存）
- DNS 缓存或者预处理（DNS Prefetch），减少 DNS 的查找
- 设置本地的离线存储（Manifest）或者把一些不经常更改的数据做本地临时存储（webstorage、indexdb）等
- 部署 CDN（地域分布式服务器或者增加服务器）
- 建立 Connection:keep-alive TCP 长连接 和 Cache-Control 和 Expires Http 的强缓存
- 使用 http2 版本协议（好处：可以多条 TCP 通道共存 => 管道化链接）
- 一个项目分为不同的服务器。例如：资源 web 服务器、数据服务器、图片服务器、视频服务器、等，合理利用服务器资源，但是会导致过多的 DNS 解析

### 代码

- 减少直接对 DOM（减少 DOM 的回流和重绘），当代项目基本上都是基于 MVVM/MVC 数据驱动视图渲染，对 DOM 的操作框架会通过虚拟 DOM 进行 DOM Diff 精确渲染，性能要高效很多
- 减少对闭包的使用，过多的使用闭包会产生很多不销毁的内存，处理不当会导致内存溢出“栈溢出”
- 对于动画来说：能用 CSS 解决的不用 JS（能够用 transform 处理不使用传统 css 样式，transform 会开启硬件加速，不会引发回流），能用 reaquestAnimationFrame 解决的不用定时器
- 避免使用 iframe：iframe 会嵌入其他页面，会吧嵌入的页面也渲染了
- 低耦合高内聚（基于封装的方式减少页面中的冗余代码，提高代码使用率）
- 尽可能使用事件委托
- 避免出现死循环或者嵌套循环
- 项目中尽可能使用异步编程来模拟出多线程的效果，避免主线程阻塞（异步操作基于 Promise 设计模式来管理）
- JS 中不要使用 with （不知道是什么 但是性能特别差）
- 避免使用 CSS 表达式
- 函数的防抖和节流
- 减少使用 eval（主要原因是防止压缩代码的时候，由于符号书写不规范导致代码混乱） 性能消耗可忽略不计
- 减少 filter 滤镜的使用
- 尽可能减少 table 布局
- 尽可能减少选择器的层级（选择器是从右向左解析）
- 手动回收堆栈内存（赋值为 null）

## 错误监控

### 即使运行错误（代码）

- `try...catch`
- `window.onerror`

### 资源加载错误

- `object.onerror`
- `performance.getEntries()`
- `Error 事件捕获`

## CSS提高页面渲染速度

### 内容可见效(content-visibility)

> 我们可以使用CSS的`content-visibility`来跳过屏幕外的内容渲染。也就是说，如果你有大量的离屏内容（Off-screen Content），这将会大幅减少页面渲染时间

有了CSS的`content-visibility`属性，影响浏览器的渲染过程就变得更加容易。本质上，这个属性 **改变了一个元素的可见性，并管理其渲染状态**。

