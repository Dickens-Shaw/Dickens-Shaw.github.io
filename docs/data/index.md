## 时间复杂度

通常使用最差的时间复杂度来衡量一个算法的好坏

对于一个算法来说，可能会计算出操作次数为 aN + 1，N 代表数据量。那么该算法的时间复杂度就是 O(N)。因为我们在计算时间复杂度的时候，数据量通常是非常大的，这时候低阶项和常数项可以忽略不计

当然可能会出现两个算法都是 O(N) 的时间复杂度，那么对比两个算法的好坏就要通过对比低阶项和常数项了

## 栈

栈是一个线性结构，在计算机中是一个相当常见的数据结构。

栈的特点是只能在某一端添加或删除数据，遵循先进后出的原则

应用：Vue 中关于模板解析的代码，就有应用到匹配尖括号的内容

## 队列

队列是一个线性结构，特点是在某一端添加数据，在另一端删除数据，遵循先进先出的原则

## 链表

链表是一个线性结构，同时也是一个天然的递归结构。

链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大

由于其非连续内存的特性导致链表非常适用于频繁插入、删除的场景，而不见长于读取场景

- 单向链表：
  单向链表的节点通常由两个部分构成,一个是节点储存的值 val,另一个就是节点的指针 next
- 双向链表：
  双向链表多了一个新的指针 prev 指向节点的前一个节点,当然由于多了一个指针,所以双向链表要更占内存
- 循环链表：
  将单向链表的尾部指针指向了链表头节点

### 反转单向链表

思路：使用三个变量分别表示当前节点和当前节点的前后节点

```js
function reverseList(head) {
  if (!head || !head.next) return head // 如果链表为空或只有一个节点，直接返回
  // 初始设置为空，因为第一个节点反转后就是尾部，尾部节点指向 null
  let prev = null
  let current = head
  // 判断当前节点是否为空
  // 不为空就先获取当前节点的下一节点
  // 然后把当前节点的 next 设为上一个节点
  // 然后把  current 设为下一个节点，prev设为当前节点
  while (current) {
    let next = current.next
    current.next = prev
    prev = current
    current = next
  }
  return prev
}
```

## 堆

堆通常是一个可以被看做一棵树的数组对象。

堆的实现通过构造二叉堆，实为二叉树的一种。这种数据结构具有以下性质。

- 任意节点小于（或大于）它的所有子节点
- 堆总是一棵完全树。即除了最底层，其他层的节点都被元素填满，且最底层从左到右填入。
  将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆

## 树

- 二叉树
  二叉树是树中最常用的结构，同时也是一个天然的递归结构。

二叉树拥有一个根节点，每个节点至多拥有两个子节点，分别为：左节点和右节点。树的最底部节点称之为叶节点，当一颗树的叶数量数量为满时，该树可以称之为满二叉树

- 二分搜索树
  也是二叉树，拥有二叉树的特性。但是区别在于二分搜索树每个节点的值都比他的左子树的值大，比右子树的值小

- 二分搜索算法：

  - 计算数组中间点的位置，取到中间点的值

  - 根据中间点的值与查找值的大小关系，确定往数组的左半部分或者右半部分查找

  - 重复上面两步，直到查找到所需的值，或者查找完整个数组， 确认值不存在
